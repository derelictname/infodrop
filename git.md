# git

```
* 633e6fd (HEAD -> b5) Добавил библиотеку
| * a116155 (b3) Добавил сортировку
| | * 2c627a7 (b4) Рефакторинг
| | | *   d9ea197 (b2) Объединил исправления
| | | |\
| | |_|/
| |/| |
| * | | 2f27fa8 Убрал опечатку
|/ / /
| | | * cc7239e (master) Объединил код
| | |/|
| |/|/
| | * cd55e2e Переписал функцию
| * | 756a56c Очистил код
| | | * 6476854 (b1) Объединил наработки
| |_|/|
|/| |/
| |/|
| * | ec0bcd7 Добавил тесты
* | | 81d030d Добавил документацию
| |/
|/|
* | a93c3d2 Исправил ошибку
|/
* 0d19eb5 Добавил файлы
```

## Как устроен Git

Git - это история изменений файлов в папке. Чтобы лучше понять, как работает Git, лучше всего поработать с низкоуровневыми командами.

Для начала создадим новое хранилище истории для текущей папки

    git init

Состояние файлов сохраняется в виде их содержимого в объектах **blob**, поэтому создадим blob обычного текстового файла

    echo 'люблю яблоки' | git hash-object -w --stdin

Объекты хранятся в папке `.git/objects`. Содержимое текстового файла появилось в виде blob в файле `.git/objects/f0/2e02a059f190d3e68d42f8438fa3f094eda1b5`. Имя папки вместе с именем файла это чексумма SHA1 содержимого blob. Это образует контекстно-адресуемое хранилище, в котором расположение файлов связано с их содержимым.

Имена файлов и их расположение в папках хранится в виде объектов **tree**. Один tree содержит информацию о именах и чексуммах файлов в одной папке, а также других tree, которые хранят информацию о вложенных папках.

```
tree 7c40534e0fe0bc3e4507ff5c39f3d33c513b6dbb
├── tree myfolder1 83781f91be8e9dcde382a873f2ea4b25240a32bd
│   └── blob sourcefile.c eae0203f03b1864f79f8a4c9e11cc85b503317bb
├── tree myfolder2 29f2577dbbf09f655fd0941927c37f9c04ea4f1e
│   ├── blob program.py b03858d332ea0ac2fe445b257d24454458e54b8d
│   └── blob script.sh e96f119abc426f9b89bfab4774c17e977df6a500
├── blob notes.txt b4e9425c74ae5608b2e25e85f9d8ee9da6565bda
└── blob users.csv 2a1b358981b813acb2b22abd50fb074da249f255
```

В данном примере есть самый верхний tree, который содержит чексуммы и имена других blob и tree, а те в свою очередь содержат чексуммы других blob и tree. При изменении файла меняется и его чексумма, а значит изменятся и все tree объекты, содержащие его.

Создадим tree с созданным ранее blob

    echo -e '100644 blob f02e02a059f190d3e68d42f8438fa3f094eda1b5\tnote.txt' | git mktree

Просмотрим созданный tree

    git ls-tree -r -t 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

Комбинация из объектов blob и tree позволяет фиксировать состояние файлов при каждом изменений. Так Git ведёт учёт истории изменений.

Но помимо конкретного tree, обозначающего состояние директории, в Git также используется ещё один объект - **commit**. Он нужен для привязки к самому верхнему tree метаинформации о том, кто, когда и зачем сделал изменения в файлах. Для этого commit хранит чексумму одной версии самого верхнего tree, имя автора, дату и комментарий.

Поэтому сначала представимся

    git config user.name Вася Пупкин
    git config user.email v.pupkin@example.org

И создадим commit с нашим tree

    echo 'создал заметку' | git commit-tree 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

commit могут также хранить чексумму предыдущего commit, чтобы выстраиваться в историю изменений.

Создадим следующую версию данных в blob, а за ним tree и commit с чексуммой предыдущего

    echo 'люблю апельсины' | git hash-object -w --stdin
    echo -e '100644 blob 3afe8b4acba7ef2a3753c7726a3fad921e3169f5\tfile1.txt' | git mktree
    echo 'поменял вкусы' | git commit-tree 4279b58515af6b00c0c74e963b69f86577fd6050 -p 1160171502ebab31a3cce78fa310afa5971dbc6c

История изменений может **разделяться** на разные ветви, тогда у разных commit может быть один общий. Либо история разных ветвей может снова **объединяться**, тогда один commit содержит чексумму нескольких предыдущих.

Просмотрим созданные нами объекты

    git cat-file --batch --batch-all-objects

При работе с Git также используется специальный файл **index** (его ещё также называют stage или cache). Некоторые команды сохраняют в него список файлов и папок для формирования самого верхнего tree, который будет записан в commit. Это используется для частичного занесения изменённых файлов в commit.

Пример ручного добавления записи в index

    git update-index --add --cacheinfo 100644 3afe8b4acba7ef2a3753c7726a3fad921e3169f5 folder1/folder2/file1.txt

Создаём tree из текущего index

    git write-tree

Ещё при работе многих команд учитываются **ссылки**. Они являются более понятным обозначением чексумм commit. Создаются ссылки в виде файлов с чексуммой внутри.

Создадим ссылку master на наш последний commit, которая обозначит имя нашей текущей ветки истории

    echo ed5e74821d5e398855f5dece56cb08ce3f7ed2c7 > .git/refs/heads/master

Виды ссылок

- **branch** - ссылка на последний commit в какой-либо ветке нескольких commit (`refs/heads/`)
- **HEAD** - указывает на ветку или commit и обозначает наше текущее положение в истории изменений
- **tag** - просто удобная ссылка на любой объект, но чаще всего commit (`refs/tags/`)
- **commit-подобный tag**- расширенная версия tag для комментариев (на него в свою очередь ссылается обычный tag)
- **remote** - указатель на ветку в другом Git хранилище, даже на другом компьютере в сети (`refs/remotes/<имя_хранилища>/`)

## Обычная работа с Git

В процессе обычной работы используются команды, которые выполняют сразу много действий в Git. Поэтому для их понимания и необходимо было разобрать низкоуровневое устройство Git.

Добавляем в Git все новые изменения в папке

    git add -A

Эта команда сначала добавляет в index разницу между ссылкой `HEAD` и рабочей папкой (изначально `HEAD` указывает на master, который пока не создан). Все изменения фиксируются в объектах blob и tree.

Если нужно отменить добавление, то сбросим index. По умолчанию сброс к текущему `HEAD`. Опция `--hard` также сбрасывает и содержимое папки.

    git reset

Теперь мы через commit фиксируем под своим именен точку в истории изменений

    git commit -m 'свой комментарий к сделанным изменениям'

Команда проверит index, создаст самый верхний tree и запишет его чексумму в новый commit. Если это не первый commit, то также добавит чексумму предыдущего commit и переместит ссылку HEAD на новый commit.

В index можно добавлять изменения файлов частями

- `git add -i` - добавление изменений с помощью командного меню
- `git add -p` - раздельное внесение изменений в файле

Некоторые полезные команды

- `git log --graph --oneline --all` - просмотреть историю в компактном виде
- `git show a472be2` - показать, что было изменени в конкретном commit
- `git diff 2b93ay5 6a94e` - сравнить два commit
- `git revert eb21ew2` - создать "обратный" commit, который применяет изменения, сделанные относительно предыдущего commit
- `git commit --amend` - выполнить commit, заменив текущий commit (для исправления)
- `git commit --amend --author="John Doe <john@doe.org>" --no-edit` - исправить автора последнего commit

## checkout

Перемещение на момент в истории. С помощью `git checkout` можно выгрузить в текущую папку старое состояния файлов, указав branch, commit или tree (можно не полную чексумму)

    git checkout 9dd5bt4

Если у нас были какие-то изменения файлов, то Git не даст их потерять, предложив их сначала сохранить хотя бы в stash. Если нас это не волнует, то можно выполнить выгрузку принудительно опцией `-f`.

Переместившись и сделав новый commit, получится новая ветка истории.

`checkout` и `reset` не трогают файлы, которые никогда не добавлялись в Git. Такие файлы можно удалить командой `git clean`.

Прочее

- `git checkout 47c98a3 .` - выгрузить tree в указанную папку

## branch

branch - это ссылка, под которой понимают ветку изменений, подряд идущие commit. Их может быть несколько. Ветки могут разделяться и объединяться. Используется для удобного различения разных веток истории.

При создании хранилища Git создаётся ветка master. Точнее создаётся ссылка HEAD, указываются на master, но сама ссылка master будет создана при создании первого commit. Иначе ей не на что указывать.

- `git branch` - показать список всех веток
- `git branch test1` - создать новую ветку для текущего commit (таким образом мы ответвимся)
- `git branch -m test1 test2` - переименовать ветку
- `git branch -f test1 2b93af3` - переместить ветку на другой commit
- `git switch test1` - переместиться на ветку и загрузить файлы из commit
- `git switch -c test1` - назначить текущему commit новый branch и направить на него HEAD
- `git checkout --orphan test1` - создать ветку без родительского commit (отделённую)

Если в хранилище есть commit, на который не указывает branch или на связанные с ним commit, то он считается недосягаемым и будет удалён (и все его blob и tree) при очистке репозитория .

- `git fsck --unreachable` - отобразить недосягаемые commit

Чтобы этого избежать, нужно переместиться на commit и создать для него ветку.

## merge

*Make us Whole*

Объединение разных веток в одну сопряжено с некоторым условием - содержимое их последних commit различается и требует ручного вмешательства для просмотра разницы и объединения различий. Но такая операция делается часто, так как ветвление очень удобно.

Начать объединение указанной ветки с текущей

    git merge test2

Нам покажут разницу между файлами с тем же именем и расположенем.

Далее

- команда `git status` подскажет необходимые действия
- по умолчанию в самих файлах в рабочей папке будут вставлены правки из обеих версий для удобства (но есть и другие варианты объединения)
- различающиеся файлы запишутся в index с разными номерами (см. `git ls-files --stage`)

После ручного объединения различий эти файлы снова добавляются в index командой `git add` и можно будет делать commit.

Если вы производите слияние историй, не имеющих общего начала, то это по умолчанию запрещено во избежание некоторых недоразумений. Но это можно всё равно сделать, добавив опцию `--allow-unrelated-histories`.

## remote

Одной из главных способностей Git - это обмен историями изменений между разными хранилищами. Это позволяет работать над проектом нескольким людям (вплоть до десятков тысяч) и обмениваться изменениями, при этом согласывая их.

Добавим удалённый репозиторий Git (можно завести, например, на сайтах GitHub или Gitlab)

    git remote add myremote1 git://example.org:2222/group1/project1.git

Теперь мы можем передать туда ветку истории

    git push mybranch1 myremote1

Если на удалённом хранилище были изменения истории (например, кто-то также передал, как и мы), мы можем загрузить их себе

    git fetch

Другие полезные команды

- `git clone git://example.org:2222/group1/project1.git` - создать хранилище на основе удалённого
- `git remote -v` - просмотреть подключенные удалённые хранилища
- `git pull` - выполнить `git fetch` и `git merge` (получение изменений и начало их слияния со своими)

## stash

Если в папке мешаются какие-нибудь файлы или изменения, но мы не хотим их удалять, их можно временно сохранить в Git.

Быстро сохранить текущие изменения в отдельный commit

    git stash -u

Просмотреть

    git stash list

Достать изменения

    git stash apply

## rebase

Пересоздание ветки. Команда в основном используется для перемещения одной ветки в конец другой вместо того, чтобы объединять их. Отсюда и название, хотя команда также позволяет пересоздать историю, например, для удаления, слияния, разделения или перестановки commit, правка авторов и комментариев.

Переместить текущую ветку с момента отделения на последний commit указанной ветки

    git rebase test1

Переместить от 3b5ae7c до c5930e5 в начало 2a288e6

    git rebase --onto 2a288e6 3b5ae7c c5930e5

Было

```
* c5930e5 (dev) commit7
* cf107c2 commit6
* f1c1faf commit5
* 3b5ae7c (master) commit4
| * 7e12d20 (branch1) commit3
|/
* 8f67736 commit2
* 2a288e6 (HEAD) commit1
```

Стало

```
* 7bb65d9 (HEAD) commit7
* 95500fc commit6
* ebdac0d commit5
| * c5930e5 (dev) commit7
| * cf107c2 commit6
| * f1c1faf commit5
| * 3b5ae7c (master) commit4
| | * 7e12d20 (branch1) commit3
| |/
| * 8f67736 commit2
|/
* 2a288e6 commit1
```

С помощью интерактивного режима можно выполнить более детальное пересоздание

    git rebase -i 9e6a86a~

Выведется весь отрезок истории от указанного commit до текущего. Слева будет применяемое действие, снизу будет справка по действиям. Например, для объединения нескольких commit меняем `pick` у идущих после него на `squash`. Чтобы наоборот разбить commit на несколько, пишем `edit`. После установки действий сохраняем файл.

На каждый `edit` происходит checkout. Вносим нужные исправления и потом

    git add изменённый_файл1 изменённая_папка2
    git rebase --continue

Либо добавляем в index только часть изменений (например, через интерактивный add) и делаем

    git commit -m 'часть правок'

Если изменение будет пересекаться со следующим commit, то rebase остановится и предложит сделать merge. Разрешаем конфликт ручным слиянием изменений и далее

    git add файл_с_объединением1
    git rebase --continue

В любой момент можно отменить процесс пересоздания истории

    git rebase --abort

## config

- `git config -l` - текущие настройки
- `git config user.name John Smith` - имя автора commit
- `git config user.email s.john@mail.net` - почта автора commit (может быть пустой строкой)
- `git config core.editor vim` - редактор примечаний при создании commit

## Прочие команды

- `git cherry-pick fc92d5s` - создать новый commit с изменениями, которые произошли в указанном commit по сравнению с его предшественником (можно использовать для перестроения цепочки commit)
- `git ls-tree -r HEAD` - список файлов в tree или commit
- `git fsck` - найти blob/tree, не связанные ни с одним commit

Удаление blob и tree, не связанных ни с одним commit

    git reflog expire --expire=now --all
    git repack -ad
    git prune

## git-filter-repo

Удаление данных из истории

https://docs.github.com/ru/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository#using-git-filter-repo

    pipx install git-filter-repo
    git-filter-repo --invert-paths --path 'passwords.txt'

