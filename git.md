# git

```
* 633e6fd (HEAD -> b5) Добавил библиотеку
| * a116155 (b3) Добавил сортировку
| | * 2c627a7 (b4) Рефакторинг
| | | *   d9ea197 (b2) Объединил исправления
| | | |\
| | |_|/
| |/| |
| * | | 2f27fa8 Убрал опечатку
|/ / /
| | | * cc7239e (master) Объединил код
| | |/|
| |/|/
| | * cd55e2e Переписал функцию
| * | 756a56c Очистил код
| | | * 6476854 (b1) Объединил наработки
| |_|/|
|/| |/
| |/|
| * | ec0bcd7 Добавил тесты
* | | 81d030d Добавил документацию
| |/
|/|
* | a93c3d2 Исправил ошибку
|/
* 0d19eb5 Добавил файлы
```

## Как устроен Git

Git - это история изменений файлов в папке. Чтобы понять, как он работает, рано или поздно придётся взглянуть изнутри. Для этого есть низкоуровневые команды.

Для начала создадим в пустой папке новое хранилище истории

    git init

Все файлы хранятся в виде объектов **blob**, но только их содержимое. Создадим blob обычного текстового файла

    echo 'люблю яблоки' | git hash-object -w --stdin

Папка `.git/objects` является хранилищем всех объектов. В ней появилась папка `f0`, а в ней файл `2e02a059f190d3e68d42f8438fa3f094eda1b5`. Вместе имя папки и файла являются значением чексуммы SHA1 от содержимого файла. Таким образом это контентно-адресуемое хранилище, так как положение файла зависит от его содержимого. Таким образом Git запоминает содержимое файлов.

Второй тип объектов - **tree** - используется, чтобы запоминать имена файлов и их положение в папках. В нём записан список blob и tree в виде имени и чексуммы. blob отвечает за то, какие файлы папке, а tree - за другие папки в текущей папке. Соответственно эти tree также содержат blob и tree. Таким образом Git запоминает структуру файлов и папок.

Выглядит это так

```
tree 7c40534e0fe0bc3e4507ff5c39f3d33c513b6dbb
├── tree myfolder1 83781f91be8e9dcde382a873f2ea4b25240a32bd
│   └── blob sourcefile.c eae0203f03b1864f79f8a4c9e11cc85b503317bb
├── tree myfolder2 29f2577dbbf09f655fd0941927c37f9c04ea4f1e
│   ├── blob program.py b03858d332ea0ac2fe445b257d24454458e54b8d
│   └── blob script.sh e96f119abc426f9b89bfab4774c17e977df6a500
├── blob notes.txt b4e9425c74ae5608b2e25e85f9d8ee9da6565bda
└── blob users.csv 2a1b358981b813acb2b22abd50fb074da249f255
```

Закономерным образом один tree будет являться самым главным, так как он является отслеживаемой папкой и содержит все остальные blob и tree, а та в свою очеред вложенные blob и tree.

Стоит заметить, что при изменении blob изменится его чексумма, а значит и чексумма tree, который ссылается на него и так далее вверх до основного tree.

Создадим tree с созданным ранее blob

    echo -e '100644 blob f02e02a059f190d3e68d42f8438fa3f094eda1b5\tnote.txt' | git mktree

Просмотрим созданный tree

    git ls-tree -r -t 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

Объекты blob и tree используются только для запоминания содержимого одной папки и всего, что в ней. Но когда мы начинаем работать с содержимым и вносить изменения, то возникает необходимо запоминать прошлые версии файлов. Для ведения истории изменений в Git используется третий тип объектов - **commit**. В нём записывается основной tree, а также сопутствующая информация: дата, автор изменений, примечание.

Чтобы создавать commit, сначала необходимо указать автора

    git config user.name Вася Пупкин
    git config user.email v.pupkin@example.org

Теперь создаём commit с нашим tree

    echo 'создал заметку' | git commit-tree 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

Когда появляется второй и далее commit, то для выстраивания их в логическую последовательность в них записывается также чексумма предыдущего commit.

Создадим следующую версию данных в blob, а за ним tree и commit с чексуммой предыдущего

    echo 'люблю апельсины' | git hash-object -w --stdin
    echo -e '100644 blob 3afe8b4acba7ef2a3753c7726a3fad921e3169f5\tfile1.txt' | git mktree
    echo 'поменял вкусы' | git commit-tree 4279b58515af6b00c0c74e963b69f86577fd6050 -p 1160171502ebab31a3cce78fa310afa5971dbc6c

Последовательность commit может разделяться на несколько историй изменений. У них один общий commit с чексуммой, но далее идёт уже две или более параллельных цепочек commit.

Истории изменений могут также и объединяться в одну. В таком случае в объединяющем по смыслу commit будет указано несколько родительских.

Теперь просмотрим все созданные нами объекты через команду (можно и вручную в папке `.git/objects`)

    git cat-file --batch --batch-all-objects

Перед созданием commit обычно список изменённых файлов сначала заносят в файл `.git/index`. Например, мы изменили несколько файлов, но хотим создать commit только с частью из них, чтобы обозначить их по смыслу.

Пример ручного добавления записи в index

    git update-index --add --cacheinfo 100644 3afe8b4acba7ef2a3753c7726a3fad921e3169f5 folder1/folder2/file1.txt

Создаём tree из текущего index

    git write-tree

Последний элемент работы Git - это **ссылки**. Они являются более понятным обозначением чексумм commit. Создаются ссылки в виде файлов с чексуммой внутри.

Виды ссылок

- **branch** - ссылка на последний commit в какой-либо цепочке нескольких commit (`refs/heads/`)
- **HEAD** - указывает на ветку или commit, с которыми мы сейчас работаем
- **tag** - просто удобная ссылка на любой объект, но чаще всего на commit (`refs/tags/`)
- **commit-подобный tag**- расширенная версия tag для комментариев (на него в свою очередь ссылается обычный tag)
- **remote** - указатель на ветку в другом Git хранилище, даже на другом компьютере в сети (`refs/remotes/<имя_хранилища>/`)

Создадим ссылку master на наш последний commit, которая обозначит имя нашей текущей цепочки commit

    echo ed5e74821d5e398855f5dece56cb08ce3f7ed2c7 > .git/refs/heads/master

Цепочки (последовательности или истории) commit вместе с branch являются наиболее частым способом разделения истории изменений при работе нескольких людей над одними файлами, что позволяет контроллируемо вести совместную работу над разработкой одной программы.

## Обычная работа с Git

Добавляем в Git все новые изменения в папке

    git add -A

Эта команда сначала добавляет в index разницу между ссылкой `HEAD` и рабочей папкой (изначально `HEAD` указывает на ссылку master, которая пока не создана). Все изменения фиксируются в объектах blob и tree.

Если нужно отменить добавление, то сбросим index. По умолчанию сброс к текущему `HEAD`. Опция `--hard` также сбрасывает и содержимое рабочей папки (потеряем все сделанные изменения).

    git reset

Теперь мы через commit фиксируем изменения

    git commit -m 'свой комментарий к сделанным изменениям'

Команда проверит index, создаст самый верхний tree и запишет его чексумму в новый commit. Если это не первый commit, то также добавит чексумму предыдущего commit и переместит ссылку HEAD на новый commit.

В index можно добавлять изменения файлов частями

- `git add -i` - добавление изменений с помощью командного меню
- `git add -p` - раздельное внесение изменений в файле

Команды и примеры

- `git log --graph --oneline --all` - просмотреть историю в компактном виде
- `git show a472be2` - показать, что было изменени в конкретном commit
- `git diff 2b93ay5 6a94e` - сравнить два commit
- `git revert eb21ew2` - создать "обратный" commit, который применяет изменения, сделанные относительно предыдущего commit
- `git commit --amend` - выполнить commit, заменив текущий commit (для исправления)
- `git commit --amend --author="John Doe <john@doe.org>" --no-edit` - исправить автора последнего commit

## checkout

Перемещение по истории изменений. В рабочую папку выгружается все blob и tree указанного branch, commit или tree (можно не полную чексумму)

    git checkout 9dd5bt4

Только если Git не обнаружит изменений в рабочей папке, иначе он заствит сначала их куда-то деть, чтобы не потерять важную работу. Для игнорирования этого добавляем опцию `-f`.

Если после checkout создать commit, то это приведёт к появлению новой цепочки.

Также нужно учесть, что любые файлы в рабочей папке, которые не были ни в одном commit игнорируются командами checkout и reset. Если нужно, их можно удалить командой `git clean`.

Команды и примеры

- `git checkout 47c98a3 .` - выгрузить tree в указанную папку

## branch

branch - это ссылка, под которой понимают ветку изменений, подряд идущие commit. Их может быть несколько. Ветки могут разделяться и объединяться. Используется для удобного различения разных веток истории.

При создании хранилища Git создаётся ветка master. Точнее создаётся ссылка HEAD, указываются на master, но сама ссылка master будет создана при создании первого commit. Иначе ей не на что указывать.

Команды и примеры

- `git branch` - показать список всех веток
- `git branch test1` - создать новую ветку для текущего commit (таким образом мы ответвимся)
- `git branch -m test1 test2` - переименовать ветку
- `git branch -f test1 2b93af3` - переместить ветку на другой commit
- `git switch test1` - переместиться на ветку и загрузить файлы из commit
- `git switch -c test1` - назначить текущему commit новый branch и направить на него HEAD
- `git checkout --orphan test1` - создать ветку без родительского commit (отделённую)

Если в хранилище есть commit, на который не указывает branch или на связанные с ним commit, то он считается недосягаемым и будет удалён (и все его blob и tree) при очистке репозитория .

- `git fsck --unreachable` - отобразить недосягаемые commit

Чтобы этого избежать, нужно переместиться на commit и создать для него ветку.

## merge

_Make us Whole_

Объединение разных веток в одну сопряжено с некоторым условием - содержимое их последних commit различается и требует ручного вмешательства для просмотра разницы и объединения различий. Но такая операция делается часто, так как ветвление очень удобно.

Начать объединение указанной ветки с текущей

    git merge test2

Нам покажут разницу между файлами с тем же именем и расположенем.

Далее

- команда `git status` подскажет необходимые действия
- по умолчанию в самих файлах в рабочей папке будут вставлены правки из обеих версий для удобства (но есть и другие варианты объединения)
- различающиеся файлы запишутся в index с разными номерами (см. `git ls-files --stage`)

После ручного объединения различий эти файлы снова добавляются в index командой `git add` и можно будет делать commit.

Если вы производите слияние историй, не имеющих общего начала, то это по умолчанию запрещено во избежание некоторых недоразумений. Но это можно всё равно сделать, добавив опцию `--allow-unrelated-histories`.

## remote

Одной из главных способностей Git - это обмен историями изменений между разными хранилищами. Это позволяет работать над проектом нескольким людям (вплоть до десятков тысяч) и обмениваться изменениями, при этом согласывая их.

Добавим удалённое хранилище Git (можно завести, например, на сайтах GitHub или Gitlab)

    git remote add myremote1 git://10.20.30.40:1234/group1/project1.git

Теперь мы можем передать туда ветку истории

    git push -u mybranch1 myremote1

Необязательная опция `-u` при отправке назачает удалённую к отправляемой, что позволит писать короче

    git push

Если на удалённом хранилище были изменения истории (например, кто-то также передал, как и мы), мы можем загрузить их себе

    git fetch

Команды и примеры

- `git clone git://example.org:2222/group1/project1.git` - создать хранилище на основе удалённого
- `git remote -v` - просмотреть подключенные удалённые хранилища
- `git pull` - выполнить `git fetch` и `git merge` (получение изменений и начало их слияния со своими)

## stash

Если в папке мешаются какие-нибудь файлы или изменения, но мы не хотим их удалять, их можно временно сохранить в Git.

Быстро сохранить текущие изменения в отдельный commit

    git stash -u

Просмотреть

    git stash list

Достать изменения

    git stash apply

## rebase

Пересоздание ветки. Команда в основном используется для перемещения одной ветки в конец другой вместо того, чтобы объединять их. Отсюда и название, хотя команда также позволяет полностью пересоздать историю commit, например, для их удаления, слияния нескольких в один, разделения одного на несколько, перестановки местами, правки авторов и комментариев.

Переместить текущую ветку с момента отделения на последний commit указанной ветки

    git rebase test1

Переместить от 3b5ae7c до c5930e5 в начало 2a288e6

    git rebase --onto 2a288e6 3b5ae7c c5930e5

Было

```
* c5930e5 (dev) commit7
* cf107c2 commit6
* f1c1faf commit5
* 3b5ae7c (master) commit4
| * 7e12d20 (branch1) commit3
|/
* 8f67736 commit2
* 2a288e6 (HEAD) commit1
```

Стало

```
* 7bb65d9 (HEAD) commit7
* 95500fc commit6
* ebdac0d commit5
| * c5930e5 (dev) commit7
| * cf107c2 commit6
| * f1c1faf commit5
| * 3b5ae7c (master) commit4
| | * 7e12d20 (branch1) commit3
| |/
| * 8f67736 commit2
|/
* 2a288e6 commit1
```

С помощью интерактивного режима можно выполнить более детальное пересоздание

    git rebase -i 9e6a86a~

Выведется весь отрезок истории от указанного commit до текущего. Слева будет применяемое действие, снизу будет справка по действиям. Например, для объединения нескольких commit меняем `pick` у идущих после него на `squash`. Чтобы наоборот разбить commit на несколько, пишем `edit`. После установки действий сохраняем файл.

На каждый `edit` происходит checkout. Вносим нужные исправления и потом

    git add изменённый_файл1 изменённая_папка2
    git rebase --continue

Либо добавляем в index только часть изменений (например, через интерактивный add) и делаем

    git commit -m 'часть правок'

Если изменение будет пересекаться со следующим commit, то rebase остановится и предложит сделать merge. Разрешаем конфликт ручным слиянием изменений и далее

    git add файл_с_объединением1
    git rebase --continue

В любой момент можно отменить процесс пересоздания истории

    git rebase --abort

## config

- `git config -l` - текущие настройки
- `git config user.name John Smith` - имя автора commit
- `git config user.email s.john@mail.net` - почта автора commit (может быть пустой строкой)
- `git config core.editor vim` - редактор примечаний при создании commit

## Команды и примеры

- `git cherry-pick fc92d5s` - создать новый commit с изменениями, которые произошли в указанном commit по сравнению с его предшественником (можно использовать для перестроения цепочки commit)
- `git ls-tree -r HEAD` - список файлов в tree или commit
- `git fsck` - найти blob/tree, не связанные ни с одним commit

Удаление blob и tree, не связанных ни с одним commit

    git reflog expire --expire=now --all
    git repack -ad
    git prune

## git-filter-repo

Удаление данных из истории

https://docs.github.com/ru/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository#using-git-filter-repo

    pipx install git-filter-repo
    git-filter-repo --invert-paths --path 'passwords.txt'
