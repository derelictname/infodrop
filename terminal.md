# README

https://ru.wikipedia.org/wiki/TTY-абстракция

После перфокарт для взаимодействия с компьютером стали использовать **терминал** - отдельное от компьютера самостоятельное устройство из клавиатуры и монитора для обмена текстом с компьютером. В качестве первого телминала был **телетайп**, широко применявшийся в то время в телеграфии. Со временем вместо печатный вывод заменили на ЭЛТ, терминалы превратились в видеотерминалы, добавили микропроцессор.

Терминал подключался через UART порт. **Драйвер порта UART** в операционной системе имеет буфер для промежуточных манипуляций над передаваемым текстом (редактирование, отображение ввода, перенос строки), который может отключаться, например, для текстовых редакторов, которые сами отвечают за изменение текста. Такие манипуляции называются **дисциплиной**. Отдельный **драйвер TTY** управляет сеансом обмена текстом, определяя программу, которая будет получать вводимые данные, либо передавать данные на приём. Вся эта система является **устройством TTY** в виде файла в папке `/dev/`. Для этого программа login при входе в систему передаёт пользователю права на файл конкретного терминала.

Сейчас физические терминалы и UART порты ушли в прошлое, остались драйвер TTY и дисциплина, с которыми теперь взаимодействует **эмулятор терминала** (также есть виртуальные терминалы по нажатию на Alt + F1-F7). Для общения с программой он создаёт **виртуальный терминал** называемый **псевдотерминал** (`man pty`). Функция `int posix_openpt(int flags)` создаёт в `/dev/pts/` файл, выполняющий роль **slave** и возвращает файловый дескриптор, выполняющий роль **master**. Эмулятор терминала соединяется с master, master - со slave через Unix socket, а slave - с программой. Таким образом между эмулятором терминала и программой двухсторонний текстовый обмен.

Например, [gnome-terminal использует libvte для создания псевдотерминала](https://github.com/GNOME/vte/blob/fb3220bee959d37f58daf702165f142ef9fab9f4/src/pty.cc)

Программы могут менять своё поведение в зависимости от наличия терминала в stdin/stdout, например, предлагать интерактивное взаимодействие (ввод данных, выбор пунктов меню) и выводить результат с форматированием и управляющими символами

```python
import sys

name = 'неизвестный пользователь'

if sys.stdin.isatty():
    # Интерактивное получение ввода через терминал
    name = input('Введите ваше имя: ')
else:
    # Без использования терминала (например, через PIPE)
    name = sys.stdin.read().rstrip()

if sys.stdout.isatty():
    # Цветной вывод в терминал
    print(f'\u001b[48;5;208mПривет, {name}!\u001b[0m')
else:
    # Обычный вывод, который подойдёт для записи в файл
    print(f'Привет, {name}')
```



```python
import pty
pty.spawn(['ssh', 'user@server'])

import subprocess
subprocess.run(['ssh', 'user@server'])
```

Bash

```
if [ -t 0 ]; then
    echo 'STDIN сейчас не связан с терминалом'
fi

# Пример stdout без терминала
password=$(pwgen)
pwgen > password
ssh user1@server1 pwgen
```


Вывести файл терминала, подключенного к STDIN

    tty

Вывод настроек терминала

    stty -a

Отключить автоперевод длинных строк

    tput rmam
    man 5 terminfo
    man termcap
    man tput

Кол-во псевдотерминалов

    echo "$(cat /proc/sys/kernel/pty/nr)/$(cat /proc/sys/kernel/pty/max)"

Эмулятор терминала в ретро стиле

    apt install cool-retro-term

Вставка управляющих символов

    Ctrl + v
    Ctrl + g

Стереть слово

    Ctrl + w

## X-terminal

Помимо текстовых терминалов были ещё и Х-терминалы, соединявшиеся с X Window System по протоколу X11, но из-за появления в компьютерах видеокарт и периферийных устройств Х-терминалы стали не нужны, код X Window System перестал поддерживаться, все просто надстраивают костыли над ним. Поэтому появился Wayland, в котором убраны лишние слои абстракции от железа, окна напрямую отрисовываются в видеодрайвере, что повышает отзывчивость интерфейса.


