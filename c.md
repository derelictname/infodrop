# start

```c
#include <stdio.h>
int main(int argc, char **argv)
{
        for (int i = 1; i < argc; i++) {
                printf("spice %d = %s\n", i, argv[i]);
        }
        return 0; // код возврата программы (необязательно)
}
```

Сборка с подробным выводом действий, сохранением промежуточных этапов сборки и запуск, в случае успешной сборки

    gcc -v --save-temps -fno-asynchronous-unwind-tables file1.c -o file1 && ./file1 sugar salt pepper

Появятся отдельные файлы, которые отражают результат каждого этапа сборки

1. Выполнение команд препроцессора (макросов). В коде программы ищутся команды `#include`, `#define` и другие и выполняются изменения кода программы (например, вставляется код из другого файла или подставляется текст).
2. Преобразование в код на ассемблере.
3. Преобразование в машинный код в файле особого формата - объектный файл-модуль. Его можно просмотреть через hex-редактор, он похож на код ассемблера. Такой файл ещё не готов к запуску.
4. Вставка внутрь файла других файлов-модулей с машинным кодом (компоновка) и замена ассемблерных меток/символов на реальные адреса внутри файла (линковка). Для обращений к меткам/символам в других файлах вставляется файл-модуль `ld.so`. Также вставляется файл-модуль `crt1.o` (C Run Time) для начального этапа запуска программы.

**Команды препроцессора** - команды, выполняемые отдельной программой - препроцессором Си, которая производит изменения кода программы.

```c
#include "myprogram.h"  // вставка файла из текущей папки
#include <stdio.h>      // вставка файла из из системного пути

#define NUMBER int      // NUMBER будет заменён на int

int main(void)
{
        NUMBER a = 10;

#ifdef NUMBER           // условное использование участка кода
        a = a + 10;
#endif
}
```

При переводе кода в ассемблер объявления и определения функций становятся метками/символами, которые потом будут заменены на рабочие адреса. Поэтому перед обращением к функции должно быть хотя бы её объявление. Принято создавать отдельно подключаемые файлы с объявлениями функций (а также `#define`) и делать `#include` в файлах, где эти функции будут использоваться.

```c
// Объявление функций
void fun1(void);
void fun2(void);

int main(void)
{
        fun1();
}

// Определение функций
void fun1(void)
{
        int a = 10; // Значение хранится в stack памяти до завершения функции
        printf("fun1 executed\n");
        fun2();
}

void fun2(void)
{
        printf("fun2 executed\n");
        fun1();
}
```

В данном примере две функции вызывают друг друга, что приводит к бесконечной рекурсии. Так как предыдущий вызов функции не завершается, то эти вызовы заполняют в памяти процессора стек вызовов используемыми переменными. Стек вызовов переполняется и программа пытается обратиться к участку памяти, предназначенному для другого сегмента - [ошибка сегментации](https://ru.wikipedia.org/wiki/Сегментная_адресация_памяти).

Компилятор может исправить это при переводе в ассемблер, если включить опцию оптимизации `-O2`. Вызовы функции `call` заменятся на прыжок `jne` и тело функций превратится в цикл. Но, чтобы оптимизация сработала, взаимные вызовы функций должны стоять последними (хвостовая рекурсия).

**Преобразование типа** - изменение типа переменной при операциях над разными типами. Происходит незаметно для программиста, поэтому желательно делать его явно.

```c
int a = 15;
double b = 3.1, c;
c = a / b;          // неявное
c = (double)a / b;  // явное
printf("%d\n", (int)1.9);
```

**Структура** - составная переменная, хранящая в себе несколько хранящихся рядом переменных. Может происходить выравнивание их расположения для оптимизации под определённую архитектуру, но некоторые компиляторы позволяют это отключить (упаковка).

```c
struct snake {
        int pos_x;
        int pos_y;
        char direction;
        int length;
};
struct snake snake1 = { 50, 50, 'w', 1 };
struct snake snake2 = { 20, 20, 's', 1 };
snake1.length++;
printf("Current snake size = %d\n", snake1.length);

// Анонимная инициализация и с объявлением переменной
struct {
        int id;
        int x;
        int y;
} object1; 
```

**Перечисление** - набор именованных целочисленных констант. Используется для определения возможных значений какой-либо переменной (компилятор замечает попытку присвоения из другого перечисления).

```c
enum tea { WHITE, YELLOW, GREEN }; // 0, 1, 2
enum tea tea1 = GREEN; // 2
enum hexword { DEAD = 0xdead, FOOD = 0xf00d };
enum hexword myhexword = FOOD;
printf("tea %d is my %x\n", tea1, myhexword);
enum { ONE, TWO, THREE }; // анонимная инициализация
enum { FALSE, TRUE } enabled; // анонимная инициализация с объявлением переменной
```

**Объединение** - использование одного и того же участка памяти в виде разных типов переменных. Размер участка определяется по наибольшему типу. Используется в основном для переносимости программы на разное оборудование, чтобы значение гарантированно помещалось в переменную.

```c
union my_cool_union {
        long a;
        int b;
};
union my_cool_union c;
c.b = 123;
printf("%ld\n", c.a);
```

**Структура с битовыми полями** - структура со полями произвольной длины в битах. Размер и расположение данных в памяти будет зависеть от типа полей и порядка их расположения. Например, несколько полей может уместиться в первом из них, если их длина в сумме меньше длины типа данных.

```c
// Для  удобства объединим структуру с битовыми полями и char
union {
        struct {
                unsigned char field1 : 2;
                unsigned char field2 : 2;
                unsigned char field3 : 4;
                // Вся структура займёт 1 байт,
                // так как все поля умещаются в первый char
        } struct1;
        unsigned char char1;
} union1;

int main(void)
{
        union1.struct1.field1 = 0b00;
        union1.struct1.field2 = 0b11;
        union1.struct1.field3 = 0b1011;

        // Печатаем на экран значение структуры в виде 0 и 1 (длина unsigned char)
        for (int i = sizeof(union1.char1) * 8 - 1; i >= 0; i--)
                printf("%d", (union1.char1 & (1 << i)) >> i);
        printf("\n");
}
```

**Синоним типов** - создание нового имени для уже существующего типа данных. Используется для удобства и читаемости. Часто используется вместе с анонимной инициализацией типа данных.

```c
typedef int number;
number n1 = 123;

// Определение типа для анонимного перечисления
typedef enum { WOOD, METAL, STONE } block_type;
block_type door = STONE;

// Определение типа для анонимной структуры
typedef struct {
        int x;
        int y;
        int size;
        int shape;
} primitive;

primitive square1 = { 0, 0, 10, 4 };
printf("primitive size is %d\n", square1.size);
```

**Статическая переменная**  - в отличии от обычной переменной будет создана в ассемблере, как метка/символ, а не запись значения в регистр. Таким образом их значение хранится в течении всей работы программы и к ним можно обращаться из любого места.

```c
void f(void)
{
        static int n = 0;
        n++;
        printf("%d\n", n);
}
int main(void(
{
        f(); // 1
        f(); // 2
}
```

**Указатель** - переменная, которая содержит адрес другой переменной в памяти. Используется при адресной арифметике и работы со значениями за пределами области видимости. Указатели тоже имеют типы, как и у переменных, на которые указывают, чтобы компилятор знал сколько считывать байт при обращении к значению.

```c
void f(int *p) // функция принимает указатель
{
        int v = *p; // берём значение переменной из указателя
        *p = v + *p - 4; // изменяем переменную по указателю
}
int main(void)
{
        int n = 10;
        int *z = &n; // получаем указатель на переменную
        f(z);
        printf("address: %p, value: %d\n", z, n);
}
```

Указатели и структуры

```c
struct obj {
        int id, x, y;
};

struct obj obj1; // создаём переменную
struct obj *p_obj1 = &obj1; // сохраняем адрес структуры в указатель

obj1.x = 15; // обычное обращение к полю
p_obj1->y = 32; // обращение к полю через указатель
```


**Массив** - не тип данных, а инициализатор указателя на первый элемент последовательно расположенных данных. Обращение к элементам выполняет вычисление смещения относительно адреса массива, либо можно обращаться через адресную арифметику. На этапе сборки известен размер массива с учётом типа данных.

```c
int array1[] = {1, 2, 3};
printf("%p %p %d\n", array1, &array1[0], *array1);
```

**Строка** - последовательность байт с нулевым байтом в конце. Может быть создана в виде указателя на первый символ или в виде массива.

В случае массива данные хранятся в stack памяти

```c
char string1[20];
char string2[] = "string literal 1"; // копируется строка
char string2[3] = 'a';
```

В случае указателя сам он будет в stack памяти, а данные по нему - в text памяти, которая только для чтения, а изменение приведёт к *неопределённому поведению*

```c
char *string3;
char *string4 = "string literal 2"; // указатель на литерал
string4[3] = 'a';
```

Присвоение строкового литерала символьному указателю приводит к неявному преобразованию в указатель на первый элемент массива.

---





**Строковый литерал** - особая синтаксическая конструкция, которая преобразуется в статический безымянный массив символов.

```c
char a[] = "carrot"; // "carrot" преобразуется в
static char b[] = {'c', 'a', 'r', 'r', 'o', 't', '\0'};
```


## Этапы сборки по отдельности

```c
#include <stdio.h>

int plus(int num)
{
        return num + 2;
}

int main(void)
{
        static int zavarudo = 1234;
        printf("%d\n", plus(3));
}
```

Предобработка

    cpp myprogram.c > myprogram.i

Преобразование в ассемблер (`-fno-asynchronous-unwind-tables` отключает лишние вставки кода)

    gcc -S -fno-asynchronous-unwind-tables myprogram.i -o myprogram.s

Преобразование в объектный файл-модуль

    as myprogram.s -o myprogram.o

Компоновка и линковка

    ld myprogram.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o -o myprogram -lc

`crt1.o` - объектный файл с кодом, который мы добавляем к коду нашей программы для начального этапа запуска программы.

При запуске программы текущий процесс клонируется в оперативной памяти (`fork()`) и клон заменяется на новую программу (`execve()`). Запускает программу [загрузчик программ](https://ru.wikipedia.org/wiki/Загрузчик_программ).



- https://ru.wikipedia.org/wiki/Компилятор
- https://ru.wikipedia.org/wiki/Компоновщик
- https://ru.wikipedia.org/wiki/Исполняемый_файл
- https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format
- [Стиль оформления кода Linux](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/coding-style.rst) - отступы табом в 8 символов, что достаточно явно сигнализирует о слишком большой вложенности.
