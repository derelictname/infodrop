# start

```c
#include <stdio.h>
int main(int argc, char **argv)
{
        for (int i = 1; i < argc; i++) {
                printf("spice %d = %s\n", i, argv[i]);
        }
}
```

Сохраняем в `file1.c` и собираем программу

    gcc -v -fverbose-asm -O0 --save-temps -fno-asynchronous-unwind-tables file1.c -o file1

Промежуточные результаты сборки появятся в виде отдельных файлов.

1. Обработка макрокоманд препроцессором. Макрокоманды начинаются на `#` и выполняют вставку других файлов с кодом, замену слов, условное включение участка кода.
2. Создание кода на ассемблере.
3. Преобразование ассемблерного кода в двоичные команды в файле ELF перемещаемого типа (статическая библиотека).
4. Объединение нескольких ELF перемещаемого типа, связывание меток (замена на рабочие адреса в соответствии с таблицей меток в ELF). В итоге получаем ELF того же типа, исполняемого или совместно используемого (динамическая библиотека).

Связывание меток может происходить во время запуска программы. Для этого используется динамическая библиотека `ld.so`. Для работы программ на Си вставляется код статической библиотеки`crt1.o` (C Run Time).

Запускать для создания новых процессов можно только исполняемые ELF.

**Команды препроцессора** - команды, выполняемые отдельной программой - препроцессором Си, которая производит изменения кода программы.

```c
#include "myprogram.h"       // вставка файла из текущей папки
#include <stdio.h> // вставка файла из из системного пути

#define NUMBER int // NUMBER будет заменён на int
#define COUNT 300
#define TEST
#define ADD_10(a) a + 10 // подстановка с параметрами
#define FUN1(a, b) (a) * (b) + (a)

int main(void)
{
        NUMBER a;
        a = FUN1(1 + 2, 3); // заменится на (1 + 2) * (3) + (1 + 2)

#ifdef TEST // условное использование кода
        a = 1;
#endif
}
```

При переводе кода в ассемблер объявления и определения функций становятся метками/символами, которые потом будут заменены на рабочие адреса в оперативной памяти (с учётом смещения относительно условного начала адресов в запущенной программе). Поэтому перед обращением к функции должно быть хотя бы её объявление. Для этого было принято помещать объевления функций в отдельные файлы и делать `#include` при необходимости.

Такие вставляемые файлы называют **заголовочными**. Их расширение `.h`, а не `.c`, как у обычного кода. Также в заголовочные файлы помещают общие для всей программы определения: структуры, константы и обобщённые функции (через `#define`). Примеры можно посмотреть в `/usr/include/linux/`.

```c
// Объявление функции
void fun1(void);
void fun2(void);

int main(void)
{
        fun1();
}

// Определение функции
void fun1(void)
{
        int a = 10; // Значение хранится в "stack памяти" до завершения функции
        printf("fun1 executed\n");
        fun2();
}

void fun2(void)
{
        printf("fun2 executed\n");
        fun1();
}
```

В данном примере две функции вызывают друг друга, что приводит к бесконечной рекурсии. Так как предыдущий вызов функции не завершается, то эти вызовы заполняют в памяти процессора стек вызовов используемыми переменными. Стек вызовов переполняется и программа пытается обратиться к участку памяти, предназначенному для другого сегмента - [ошибка сегментации](https://ru.wikipedia.org/wiki/Сегментная_адресация_памяти).

Компилятор может исправить это при переводе в ассемблер, если включить опцию оптимизации `-O2`. Вызовы функции `call` заменятся на прыжок `jne` и тело функций превратится в цикл. Но, чтобы оптимизация сработала, взаимные вызовы функций должны стоять последними (хвостовая рекурсия).

## Типы переменных

Чаще всего переменные становятся инструкцией записи числа в регистр процессора. 

```c
unsigned char variable1; // инициализация переменной с длиной в 1 байт

char variable2;
/* Без явного указания все типы будут sighed, у которых первый бит используется под знак + или - для обозначения отрицательности значения. Поэтому в unsigned char диапазон возможных значений от 0 до 256, а в signed char от -127 до 128. */
```

*Тип char, возможно, так называется, потому что в него умещается буква в однобайтовой кодировке.*

**Статическая переменная** становится меткой/символом в ассемблере, как и функции. Хранится в течении всей работы программы, доступна в пределах всей программы, а каждое обращение происходит в один и тот же участок памяти (поэтому за этими обращениями нужно особенно следить, либо не использовать статические переменные).

```c
void f(void)
{
        static int n = 0;
        n++;
        printf("%d\n", n);
}
int main(void)
{
        f(); // 1
        f(); // 2
}
```

**Преобразование типа** - изменение типа переменной. При операциях над разными типами может происходить неявно, поэтому желательно делать его явно.

```c
int a = 15;
double b = 3.1, c;
c = a / b;          // неявно
c = (double)a / b;  // явно
printf("%d\n", (int)1.9);
```

**Структура** - составная переменная, хранящая в себе несколько расположенных рядом переменных. Может происходить выравнивание их расположения для оптимизации под конкретную архитектуру, но некоторые компиляторы позволяют это отключить (упаковка).

```c
struct snake {
        int pos_x;
        int pos_y;
        char direction;
        int length;
};
struct snake snake1 = { 50, 50, 'w', 1 };
struct snake snake2 = { 20, 20, 's', 1 };
snake1.length++;
printf("Current snake size = %d\n", snake1.length);

// Анонимная инициализация и с объявлением переменной
struct {
        int id;
        int x;
        int y;
} object1; 
```

**Перечисление** - набор именованных целочисленных констант. Используется для определения возможных значений какой-либо переменной (компилятор замечает попытку присвоения из другого перечисления).

```c
enum tea { WHITE, YELLOW, GREEN }; // 0, 1, 2
enum tea tea1 = GREEN; // 2
enum hexword { DEAD = 0xdead, FOOD = 0xf00d };
enum hexword myhexword = FOOD;
printf("tea %d is my %x\n", tea1, myhexword);
enum { ONE, TWO, THREE }; // анонимная инициализация
enum { FALSE, TRUE } enabled; // анонимная инициализация с объявлением переменной
```

**Объединение** - использование одного и того же участка памяти в виде разных типов переменных. Размер участка определяется по наибольшему типу. Используется в основном для переносимости программы на разное оборудование, чтобы значение гарантированно помещалось в переменную.

```c
union my_cool_union {
        long a;
        int b;
};
union my_cool_union c;
c.b = 123;
printf("%ld\n", c.a);
```

**Структура с битовыми полями** - структура со полями произвольной длины в битах. Размер и расположение данных в памяти будет зависеть от типа полей и порядка их расположения. Например, несколько полей может уместиться в первом из них, если их длина в сумме меньше длины типа данных.

```c
// Для  удобства объединим структуру с битовыми полями и char
union {
        struct {
                unsigned char field1 : 2;
                unsigned char field2 : 2;
                unsigned char field3 : 4;
                // Вся структура займёт 1 байт,
                // так как все поля умещаются в первый char
        } struct1;
        unsigned char char1;
} union1;

int main(void)
{
        union1.struct1.field1 = 0b00;
        union1.struct1.field2 = 0b11;
        union1.struct1.field3 = 0b1011;

        // Печатаем на экран значение структуры в виде 0 и 1 (длина unsigned char)
        for (int i = sizeof(union1.char1) * 8 - 1; i >= 0; i--)
                printf("%d", (union1.char1 & (1 << i)) >> i);
        printf("\n");
}
```

**Синоним типов** - создание нового имени для уже существующего типа данных. Используется для удобства и читаемости. Часто используется вместе с анонимной инициализацией типа данных.

```c
typedef int number;
number n1 = 123;

// Определение типа для анонимного перечисления
typedef enum { WOOD, METAL, STONE } block_type;
block_type door = STONE;

// Определение типа для анонимной структуры
typedef struct {
        int x;
        int y;
        int size;
        int shape;
} primitive;

primitive square1 = { 0, 0, 10, 4 };
printf("primitive size is %d\n", square1.size);
```

**Указатель** - переменная, которая содержит адрес другой переменной в памяти. Используется при адресной арифметике и работы со значениями за пределами области видимости. Указатели тоже имеют типы, как и у переменных, на которые указывают, чтобы компилятор знал сколько считывать байт при обращении к значению.

```c
void f(int *p) // функция принимает указатель
{
        int v = *p; // берём значение переменной из указателя
        *p = v + *p - 4; // изменяем переменную по указателю
}
int main(void)
{
        int n = 10;
        int *z = &n; // получаем указатель на переменную
        f(z);
        printf("address: %p, value: %d\n", z, n);
}
```

Указатели и структуры

```c
struct location {
        int id;
        int x;
        int y;
};

struct location loc1; // создаём переменную
struct location *p_loc1 = &loc1; // сохраняем адрес структуры в указатель

loc1.x = 15; // обычное обращение к полю
p_loc1->y = 32; // обращение к полю через указатель
```


**Массив** - не тип данных, а инициализатор указателя на первый элемент последовательно расположенных данных. Обращение к элементам выполняет вычисление смещения относительно адреса массива, либо можно обращаться через адресную арифметику. На этапе сборки известен размер массива с учётом типа данных.

```c
int array1[] = {1, 2, 3};
printf("%p %p %d\n", array1, &array1[0], *array1);
```

**Строка** - последовательность байт с нулевым байтом в конце. Может быть создана в виде указателя на первый символ или в виде массива.

В случае массива данные хранятся в stack памяти

```c
char string1[20];
char string2[] = "string literal 1"; // копируется строка
char string2[3] = 'a';
```

В случае указателя сам он будет в stack памяти, а данные по нему - в text памяти, которая только для чтения, а изменение приведёт к *неопределённому поведению*

```c
char *string3;
char *string4 = "string literal 2"; // указатель на литерал
string4[3] = 'a';
```

Присвоение строкового литерала символьному указателю приводит к неявному преобразованию в указатель на первый элемент массива.

---





**Строковый литерал** - особая синтаксическая конструкция, которая преобразуется в статический безымянный массив символов.

```c
char a[] = "carrot"; // "carrot" преобразуется в
static char b[] = {'c', 'a', 'r', 'r', 'o', 't', '\0'};
```


## Поэтапная сборка

```c
#include <stdio.h>

void f(void)
{
        static int n = 0;
        n++;
        printf("%d\n", n);
}

int main(void)
{
        f(); // 1
        f(); // 2
}
```

Обработка макросов препроцессором

    cpp prog1.c > prog1.i

Создание ассемблерного кода (с отключением вставок Си)

    gcc -S -fno-asynchronous-unwind-tables prog1.c -o prog1.s

Или

    gcc -S -fno-asynchronous-unwind-tables prog1.i -o prog1.s

Преобразование в статическую библиотеку

    as prog1.s -o prog1.o

Компоновка в исполняемый файл

    ld myprogram.o /usr/lib/x86_64-linux-gnu/crt1.o -lc --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o myprogram

Опции

- `crt1.o` - статическая библиотека для запуска программ на Си
- `ld-linux-x86-64.so.2` - совместно используемая библиотека для динамического связывания ссылок
- `-lc` - статическая библиотека libc, найденная в стандартной папке

При запуске программы текущий процесс клонируется в оперативной памяти (`fork()`) и клон заменяется на новую программу (`execve()`). Запускает программу [загрузчик программ](https://ru.wikipedia.org/wiki/Загрузчик_программ).



- https://ru.wikipedia.org/wiki/Компилятор
- https://ru.wikipedia.org/wiki/Компоновщик
- https://ru.wikipedia.org/wiki/Исполняемый_файл
- https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format
- [Стиль оформления кода Linux](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/coding-style.rst) - отступы табом в 8 символов, что достаточно явно сигнализирует о слишком большой вложенности.
