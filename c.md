# Си

```c
#include <stdio.h>
int main(int argc, char **argv, char **envp)
{
        for (int i = 0; envp[i] != NULL; i++) {
                printf("we know %s\n", envp[i]);
        }
        for (int i = 1; i < argc; i++) {
                printf("spice %d = %s\n", i, argv[i]);
        }
}
```

Сохраняем в `prog1.c` и запускаем препроцессор для выполнения макрокоманд `#include`, `#define` и других, которые выполняют изменение кода: вставку текста из других файлов, подмену слов, условное использование участков кода

    cpp prog1.c > prog1.i

Преобразуем код Си в код на ассемблере

    gcc -S prog1.i -fno-asynchronous-unwind-tables -o prog1.s

Описание опций

- `-S` - преобразование кода на языке Си в код на языке ассемблера
- `-fno-asynchronous-unwind-tables` - не вставлять отладочные директивы ассемблера для упрощения кода

Преобразуем текстовый код на ассемблере в двоичные машинные коды операций процессора и помещаем в файл формата *ELF перемещаемого типа*, который также называется *статической библиотекой* или *объектным файлом*

    as prog1.s -o prog1.o

Создаём *ELF исполняемого типа* с помощью компоновщика, добавляя также другие объектные файлы

    ld prog1.o /usr/lib/x86_64-linux-gnu/crt1.o --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -lc -o prog1

Описание опций

- `/usr/lib/x86_64-linux-gnu/crt1.o` - объектный файл, добавляемый в начало всех программ на Си ([подробнее про C Run Time](https://en.wikipedia.org/wiki/Crt0))
- `--dynamic-linker=/lib64/ld-linux-x86-64.so.2` - указываем путь до динамического компоновщика
- `-lc` - связывание с  *ELF совместно используемого типа* `/usr/lib/x86_64-linux-gnu/libc.so`, который будет добавляться в программу при запуске через динамический компоновщик

Компоновщик также заменяет все ассемблерные метки на реальные адреса в файле.

На выходе получаем *ELF исполняемого*, который можно запускать. Но также возможно получить *ELF совместно используемого типа*, который также называется *динамической библиотекой*, или *ELF перемещаемого типа*.

Запускаем готовую программу

    ./prog1 pepper salt cinnamon

Все предыдущие действия можно выполнить одной командой, при этом промежуточный результаты будут также созданы в виде файлов

    gcc -v --save-temps -fno-asynchronous-unwind-tables prog1.c -o prog1

Примечание: библиотеки могут быть одновременно в статическом и динамическом варианте в двух файлах с форматами `.o`, `.a` (архив) или `.so` соответственно. Тогда с помощью опции можно явно указать использование статического варианта, чтобы программа не зависела от наличия в системе нужной динамической библиотеки

    gcc -static file1.c -o file1

В этом примере будет добавлен статический вариант стандартной для языка Си библиотеки `libc.so`. Она используется по умолчанию и не требует явного указания.

## Препроцессор

Выполняет команды для изменения текста программы

```c
#include "myprogram.h" // вставка файла из текущей папки
#include <stdio.h> // вставка файла из системного пути

#define NUMBER int // NUMBER будет заменён на int
#define COUNT 300
#define TEST
#define ADD_10(a) a + 10 // подстановка с параметрами
#define FUN1(a, b) (a) * (b) + (a)
#define FUN2(a, b)               \
        {                        \
                printf("%s", a); \
                printf("%s", b); \
        }

int main(void)
{
        NUMBER a;
        a = FUN1(1 + 2, 3); // заменится на (1 + 2) * (3) + (1 + 2)

#ifdef TEST // условное использование кода
        a = 1;
#endif
}
```

`#include` обычно используется для вставки файлов с общими для всей программы макросами, обьявлениями функций, структурами и перечислениями (примеры в `/usr/include/linux/`). Эти файлы называют **заголовочными**. Их имя оканчивается на `.h`, а не на `.c`, как у обычного кода.

Иногда в заголовочные файлы вставляют защиту от их повторного добавления

```c
#ifndef MYSTRUCTS
#define MYSTRUCTS

struct teststruct1 {
        int number;
};

#endif
```

## Переменные

**Переменная** - связь определённого слова с каким-либо значением. В конечной программе это может быть значением с меткой в области памяти text или data, либо создаваться в стеке при работе функций.

```c
unsigned char var1; // инициализация переменной с длиной в 1 байт

char var2;
/* Без явного указания все типы будут sighed, у которых первый бит
используется под знак + или - для обозначения отрицательности значения.
Поэтому в unsigned char диапазон возможных значений от 0 до 256,
а в signed char от -127 до 128. */

// TODO
unsigned long long int var3 = 18446744073709551615;
float var4; // число с плавающей точкой одинароной точности
double var5; // число с плавающей точкой двойной точности
long double var6;
```

Существуют также обобщённые типы переменных, которые более конкретно определяются в заголовочном файле языка Си, различающемся в зависимости от железа со своими особенностиями вычислений.

```c
size_t a; // для размеров других переменных (результат sizeof)
ssize_t b; // то же самое, но signed (для случаев возврата значения -1)

#include <stdint.h>
uint_fast8_t c; // максимально быстрый тип для 8 бит (может быть больше 8)
uint_least8_t d; // минимально возможный тип для 8 бит (может быть меньше uint_fast8_t)
```

**Указатель** - переменная, хранящая адрес ячейки в оперативной памяти в виде обычного значения, например, `0x7fff3fedd7a8` в 32-битном варианте. Используется для обращения к данным в оперативной памяти по адресу. При изменении адреса получается сдвиг.

Для чтения значения из указателя используется разыменование. При этом компилятору необходимо заранее знать длину считываемых данных. Поэтому указатели имеют тип, как и обычные переменные. Если у указателя тип `void`, то его сначала необходимо изменить (cast).

Указатели часто используются для передачи адреса переменной в функцию и изменения самой переменной, а не копии переданного значения. Но в таком случае сложнее следить за изменением переменной в программе.

```c
int *pointer; // объявляем указатель
int value = 10; // объявляем и инициализируем переменную
pointer = &value; // сохраняем в указатель адрес переменной
void fun1(int *someptr) // функция, которая примет указатель в качестве аргумента
{
        *someptr = 100; // обратится по указателю и изменит значение
}
fun1(ptr1);
printf("address: %p, value: %d\n", ptr1, *ptr1);

void *anything; // обобщённый указатель (generic pointer)
anything = &value;
int result = *(int *)anything; // изменяем тип и разыменовываем

struct twovals {
        int x;
        int y;
};
struct twovals struct1;
struct twovals *ptr2 = &struct1;
ptr2->x = 200; // обращение к полям структуры через указатель
```

**Массив** - инициализатор указателя на первый элемент последовательно расположенных в памяти значений. Обращение к элементам происходит по индексу, который выполняет смещение адреса. На этапе сборки размер массива известен за счёт типа данных в массиве.

```c
int array1[] = {1, 2, 3};
printf("%p %p %d\n", array1, &array1[0], *array1);
```

**Строка** - указатель на первый байт последовательности байт и нулевым байтом в конце (используется для остановки при работе со сторокой в цикле). Строка создаётся либо с помощью указателя, либо с помощью массива.

```c
char *text1 = "some text"; // будет в область памяти text
char text2[] = "some text"; // будет в область памяти data
char text3[] = {'s', 'o', 'm', 'e', ' ', 't', 'e', 'x', 't', '\0'};
text1[1] = 'a'; // ошибка сегментирования, область text нельзя изменять
text2[1] = 'b';
```

**Перечисление** - набор именованных целочисленных констант. Используется для создания переменных с определёнными вариантами значений. Компилятор предупреждает при попытке присвоения из другого перечисления.

```c
enum window { GLASS, METAL, WOOD }; // внутренние значения 0, 1, 2
enum window window1 = GLASS;
if (window1 == GLASS) { printf("we have glass window\n"); }

enum hexword { DEAD = 0xdead, FOOD = 0xf00d }; // свои внутренние значения
enum { LAKE, BUSH, TREE }; // анонимная инициализация
enum { ONE, TWO, THREE } bobo; // анонимная инициализация с созданием переменной
bobo = ONE;
if (bobo == TWO) { printf("bobo is TWO\n"); }
```

**Структура** - составная переменная, хранящая в себе несколько расположенных рядом переменных - полей структуры. Может происходить выравнивание их расположения для оптимизации под конкретную архитектуру, но некоторые компиляторы позволяют это отключить (упаковка значений).

```c
struct snake {
        int x;
        int y;
        char dir;
        unsigned int len;
};
struct snake snake1 = { 50, 50, 'w', 3 }; // C89-style
struct snake snake2 = { .dir = 's', .len 4, .x 50, .y 55 };
snake1.len++;
printf("Current snake size = %d\n", snake1.len);

// Анонимная инициализация и с объявлением переменной
struct {
        int var1;
        int var2;
} object1;
```

**Объединение** - использование одного и того же участка памяти в виде разных типов переменных. Размер участка определяется по наибольшему типу. Используется в основном для переносимости программы на разное оборудование, чтобы значение гарантированно помещалось в переменную.

```c
union my_cool_union {
        long a;
        int b;
};
union my_cool_union c;
c.b = 123;
printf("%ld\n", c.a);
```

**Структура с битовыми полями** - структура со полями произвольной длины в битах. Размер и расположение данных в памяти будет зависеть от типа полей и порядка их расположения. Например, несколько полей может уместиться в первом из них, если их длина в сумме меньше длины типа данных.

```c
// Для удобства объединим структуру с битовыми полями и unsigned char
union {
        struct {
                unsigned char field1 : 2;
                unsigned char field2 : 2;
                unsigned char field3 : 4;
                // Вся структура займёт 1 байт,
                // так как все поля умещаются в первый unsigned char
        } struct1;
        unsigned char char1;
} union1;

int main(void)
{
        union1.struct1.field1 = 0b00;
        union1.struct1.field2 = 0b11;
        union1.struct1.field3 = 0b1011;

        // Печатаем на экран значение структуры в виде 0 и 1 (длина unsigned char)
        for (int i = sizeof(union1.char1) * 8 - 1; i >= 0; i--)
                printf("%d", (union1.char1 & (1 << i)) >> i);
        printf("\n");
}
```

**Синоним типов** - создание нового имени для уже существующего типа данных. Используется для удобства и читаемости. Часто используется вместе с анонимной инициализацией типа данных.

```c
typedef int number;
number n1 = 123;

// Определение типа для анонимного перечисления
typedef enum { WOOD, METAL, STONE } block_type;
block_type door = STONE;

// Определение типа для анонимной структуры
typedef struct {
        int x;
        int y;
        int size;
        int shape;
} primitive;

primitive square1 = { 0, 0, 10, 4 };
printf("primitive size is %d\n", square1.size);
```

**Преобразование типа** - изменение типа переменной. Например, обрезать лишнюю длину в переменной. При действиях над разными типами переменных может происходить неявное преобразование к одному из типов по определённым правилам. Желательно делать его явно для ясности кода.

```c
int a = 15;
double b = 3.1, c;
c = a / b;          // неявно
c = (double)a / b;  // явно
printf("%d\n", (int)1.9);
```

## Спецификаторы

**static** - спецификатор переменной с явным расположением в программе. То есть в коде ассемблера она вместо значения в регистре будет меткой со значением, которая есть всегда и видна в пределах одного объектного файла, из-за чего может быть трудно отследить причину её изменения.

```c
void f(void)
{
        static int n = 0;
        n++;
        printf("%d\n", n);
}
int main(void)
{
        f(); // 1
        f(); // 2
}
```


inline

register

- extern - объявить существование какой-либо переменной без инициализации (переменная где-то в другой части программы и будет найдена)
- volatile - отключает оптимизацию для переменной, когда компилятор заменяет упоминание переменной на её значение, если она не меняется в коде, хотя может меняться извне программы, и компилятор об этом не знает. Примеры: регистры в периферийных устройствах; глобальные переменные, используемые в обработчиках прерываний; глобальные переменные, используемые совместно несколькими задачами в многопотоковом приложении; для отладки.
- const - обеспечить гарантию невозможности повторного присвоения переменной (при этом не гарантирует неизменчивость значения, например, в случае совместного const volatile)

Все ключевые слова

|          |          |          |        |
| -------- | -------- | -------- | ------ |
| auto     | break    | case     | char   |
| const    | continue | default  | do     |
| double   | else     | enum     | extern |
| float    | for      | goto     | if     |
| int      | long     | register | return |
| short    | signed   | sizeof   | static |
| struct   | switch   | typedef  | union  |
| unsigned | void     | volatile | while  |

## Функция

Функции преобразуются в подпрограммы в ассемблере с использованием стека для хранения переданных значений и локальных переменных.

Если вызвать функцию до её **определения** в коде, то компилятор выполнит **неявное определение**, что нежелательно по ряду причин. Поэтому необходимо заранее хотя бы **объявлять** функции, например, в заголовочных файлах.

```c
// Объявление функции
void fun1(void);
void fun2(void);

int main(void)
{
        fun1(); // переход к функции, хотя её определение ниже
}

// Определение функции
void fun1(void)
{
        int a = 10; // локальные переменные хранятся в стеке
        printf("fun1 executed\n");
        fun2();
}

void fun2(void)
{
        printf("fun2 executed\n");
        fun1();
}
```

Взаимный вызов функций приведёт к бесконечной рекурсии. Так как вызов функции сохраняет информацию в стековую область памяти, то она в итоге переполнится. Если вызовы стоят в конце, то оптимизация сможет исправить это, заменив переход в подпрограмму `call` на переход к команде `jne`, который не использует стек.

Сборка с оптимизацией

    gcc prog1.c -O2 -o prog1

**Указатель на функцию** - адрес ячейки в памяти с началом функции.

```c
#include <stdio.h>

void eat(int count)
{
        printf("you ate %d apples\n", count);
}

void wash(int count)
{
        printf("you washed %d dishes\n", count);
}

// функция, принимающая указатель на функцию
void action(void (*eating_function)(int), int count)
{
        eating_function(count);
        printf("good job!\n");
}

int main(void)
{
        void (*fun_ptr)(int); // переменная для хранения указателя на функцию
        fun_ptr = eat; // присваиваем функцию указателю на функцию
        fun_ptr = &eat; // либо так
        fun_ptr(33); // вызываем функцию по указателю
        (*fun_ptr)(33); // либо так

        action(fun_ptr, 3); // передача функции в другую функцию по ссылке
        action(wash, 5); // либо так
}
```

**Переменное число аргументов** (запрещено в некоторых стандартах написания программ)

```c
#include <stdarg.h>
#include <stdio.h>

void show(int, ...);

int main(void)
{
        show(3, 321, 54, 7000);
}

void show(int count, ...)
{
        va_list ap;
        va_start(ap, count);
        for (int i = 1; i <= count; i++) {
                printf("arg passed %d\n", va_arg(ap, int));
        }
        va_end(ap);
}
```

## errno

В случае ошибки все функции стандартной библиотеки Си, которые возвращают integer, вернут `-1`, если они должны возвращать указатель, то `NULL`. При этом в переменную `errno` (определена через макрос) помещается положительное число, обозначающее конкретный вид ошибки. Это число берётся из регистра RAX, в который помещается результат системных вызовов. Для удобства в заголовочном файле `errno.h` определены константы с говорящим названием для возможных значений `errno`.

    man 3 errno

Пример

```c
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

int main()
{
        int result;

        // пытаемся переименовать файл
        result = rename("file1", "file2");

        // в случае неудачи функция вернёт -1
        if (result != 0) {
                // используем готовую функцию обработки errno
                perror("Failed to rename file");

                // или пишем свою обработку
                switch (errno) {
                case EPERM:
                        printf("Operation not permitted\n");
                        break;
                case ENOENT:
                        printf("File not found\n");
                        break;
                case EACCES:
                        printf("Permission denied\n");
                        break;
                case ENAMETOOLONG:
                        printf("Wow! Filename is too long!\n");
                        break;
                default:
                        printf("WTF?\n");
                }

                // завершаем работу программы
                return EXIT_FAILURE;
        }
        printf("File renamed\n");

        return EXIT_SUCCESS;
}
```

Программа обязательно должна как-то реагировать на возникновение ошибок в отдельных участках своей работы, так как далее могут быть использованы результаты их работы. В виду отсутствия значений поведение программы может быть неожиданным. Самый простой способ реакции на ошибку - вывести сообщение об ошибке и завершить работу программы.




## Без динамического компоновщика

Если не использовать динамический компоновщик, то отпадает и возможность использовать объектный файл C Run Time, так как он не найдёт правильно адрес главной функции. Поэтому главную функцию следует назвать именем метки по умолчанию.

```c
void _start(void)
{
        // просто делаем системный вызов завершения программы,
        // но на ассемблере
        asm("mov $60, %rax\n"
            "mov $0, %rdi\n"
            "syscall");
}
```

Сборка

    gcc -Wl,--no-dynamic-linker -nostartfiles prog1.c -o prog1

Опции

- `-Wl,--no-dynamic-linker` - не указывать динамический компоновщик
- `-nostartfiles` - не добавлять C Run Time, потому что в нём метка по умолчанию `_start` и она вызывает `main` в конце, а не завершает программу системным вызовом


## Стили кодирования

- [Linux](https://www.kernel.org/doc/html/latest/process/coding-style.html)
- [GNU](https://www.gnu.org/prep/standards/standards.html)


## LLVM


- [GCC](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) - является фронт-ендом сразу к нескольким языкам, преобразует код в AST, мидл-енд выполняет оптимизации и статический анализ, бэк-енд создаёт машинный код
- clang - компилятор и фронт-енд к языкам семейства Си, создаёт промежуточный машинный код для LLVM, который может выполнять оптимизации во время выполнения

Получение кода на высокоуровневом ассемблере LLVM IR

    clang -S -emit-llvm prog1.c

Запуск кода через интерпретатор LLVM

    lli prog1.ll

## Ссылки

- https://ru.wikipedia.org/wiki/Компилятор
- https://ru.wikipedia.org/wiki/Компоновщик
- https://ru.wikipedia.org/wiki/Исполняемый_файл
- https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format
