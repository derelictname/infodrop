# intro

Компиляторы

- GCC - предобработка, трансляция в ассемблер, машинный код, линковка
- Clang

Пример

```c
#include <stdio.h>
int main(int argc, char **argv)
{
        for (int i = 1; i < argc; i++) {
                printf("arg %d = %s\n", i, argv[i]);
        }
        return 0; // код возврата программы (необязательно)
}
```

Сборка и запуск

    gcc file1.c -o file1 && ./file1 sugar salt pepper

Команды препроцессора

```c
// вставка содержимого других файлов
#include "myprogram.h" // из текущей папки
#include <stdio.h>     // из системного пути

// подстановка текста
#define NUMBER int
NUMBER a = 10;

#define NUMBER char
NUMBER b = 20;
```

Обычно в отдельные файлы выносят объявления функций и макроопределения define, чтобы их могли использовать другие участки кода и даже другие программы

```c
// Объявление функций в текущем файле или вставляемом
void fun1(void);
void fun2(void);

// Определение функций
void fun1(void)
{
        int a = 10; // Переменные внутри функции хранятся в stack памяти и будут удалены при выходе из функции
        printf("fun1 executed\n");
        fun2();
}

void fun2(void)
{
        printf("fun2 executed\n");
        fun1();
}

int main(void)
{
        fun1();
}
```

В данном примере две функции вызывают друг друга, что создаёт рекурсию. Так как процессор хранит данные каждого вызова функций до окончания её выполнения, то произойдёт бесконечное выполнение новой функции без завершения предыдущей. В какой-то момент память в стеке вызовов закончится и будет попытка обращения за её пределы, которые недоступны (ошибка сегментации).

https://ru.wikipedia.org/wiki/Сегментная_адресация_памяти

Опция оптимизации `-O2` исправит проблему рекурсии во время трансляции в ассемблер, заменив `call` на `jne`,  превратив функции в цикл. Но оптимизация сработает только, если это хвостовая рекурсия (вызовы функции стоят в конце).

**Неявное преобразование** - автоматическое изменение типа переменной при операциях над разными типами. Для удобства рекомендуется делать явное преобразование

```c
int a = 7, b = 8, c;
c = (float)a / b;
printf("%d\n", (int)1.5);
```

**Структура** - составная переменная, похожая на класс данных в Python

```c
struct snake {
        int pos_x;
        int pos_y;
        char direction;
        int length;
};
struct snake snake1 = { 50, 50, 'w', 1 };
struct snake snake2 = { 20, 20, 's', 1 };
snake1.length++;
printf("Current snake size = %d\n", snake1.length);

struct {
        int id;
        int x;
        int y;
} object1; // инициализация анонимной структуры с объявлением переменной
```

**Перечисление** - набор именованных целочисленных констант. Используется для определения возможных значений какой-либо переменной (компилятор обнаруживает попытку присвоения из другого перечисления).

```c
enum tea { WHITE, YELLOW, GREEN }; // значения 0, 1, 2
enum tea tea1 = GREEN; // tea1 равен 2
enum hexword { DEAD = 0xdead, FOOD = 0xf00d }; // свои значения
enum hexword myhexword = FOOD;
printf("tea %d is my %x\n", tea1, myhexword);
enum { ONE, TWO, THREE }; // анонимное перечисление
enum { FALSE, TRUE } enabled; // инициализация с объявлением переменной
```

**Объединение** - позволяет в одном и том же участке памяти хранить разные переменные (размер участка определяется по наибольшему типу). Используется в основном для переносимости программы на разное оборудование, чтобы в переменную гарантированно помещалось значение.

```c
union char_and_int_union {
        long a;
        int b;
};
union char_and_int_union c;
c.b = 123;
printf("%ld\n", c.a);
```

Объединения подходят также для обращения к одному и тому же пространству разными способами (см. далее).

**Структура с битовыми полями** - структура со значениями произвольной длины в битах. Размер и расположение данных в памяти будет зависеть от типа полей и порядка их расположения. Несколько полей может уместиться в предыдущем поле, если тип поля превышает заданную для него длину. В противном случае выделяется следующее пространство в соответствии с типом следующего поля.

```c
union {
        struct {
                unsigned char field1 : 2;
                unsigned char field2 : 2;
                unsigned char field3 : 4;
                // вся структура займёт 1 байт, так как все поля умещаются
        } struct1;
        unsigned char number1;
} union1;

int main(void)
{
        union1.struct1.field1 = 0b00;
        union1.struct1.field2 = 0b11;
        union1.struct1.field3 = 0b1011;

        // Теперь мы можем обратиться к структуре битовых полей, как к одной переменной
        for (int i = sizeof(union1.number1) * 8 - 1; i >= 0; i--)
                printf("%d", (union1.number1 & (1 << i)) >> i);
        printf("\n");
}
```

**Синоним типов** - задать своё название для типа данных. Часто при определении используют анонимную инициализацию типа данных.

```c
typedef int number;
number n1 = 123;

// Определение типа для анонимного перечисления
typedef enum { WOOD, METAL, STONE } block_type;
block_type door = STONE;

// Определение типа для анонимной структуры
typedef struct {
        int x;
        int y;
        int size;
        int shape;
} primitive;

primitive square1 = { 0, 0, 10, 4 };
printf("primitive size is %d\n", square1.size);
```

**Статическая переменная**  становится постоянной, когда в других случаях создавалась бы новая переменная.

```c
void f(void)
{
        static int n = 0;
        n++;
        printf("%d\n", n);
}
int main(void(
{
        f(); // 1
        f(); // 2
}
```

**Указатель** - переменная, которая содержит адрес другой переменной в памяти. Используется при адресной арифметике и работы со значениями за пределами области видимости. Также указатели имеют тип в соответствии с типом переменной, на которую указывают, чтобы компилятор знал сколько считывать байт при обращении к значению.

```c
void f(int *p) // функция принимает указатель
{
        int v = *p; // берём значение переменной из указателя
        *p = v + *p - 4; // изменяем переменную по указателю
}
int main(void)
{
        int n = 10;
        int *z = &n; // получаем указатель на переменную
        f(z);
        printf("address: %p, value: %d\n", z, n);
}
```

**Массив** - не тип данных, а инициализатор указателя на первый элемент последовательно расположенных данных.

```c
int array1[] = {1, 2, 3};
printf("%p %p %d\n", array1, &array1[0], *array1);
```

**Строка** - последовательность байт с нулевым байтом в конце. Может быть создана в виде указателя на первый символ или в виде массива.

В случае массива данные хранятся в stack памяти

```c
char string1[20];
char string2[] = "string literal 1"; // копируется строка
char string2[3] = 'a';
```

В случае указателя сам он будет в stack памяти, а данные по нему - в text памяти, которая только для чтения, а изменение приведёт к *неопределённому поведению*

```c
char *string3;
char *string4 = "string literal 2"; // указатель на литерал
string4[3] = 'a';
```

Присвоение строкового литерала символьному указателю приводит к неявному преобразованию в указатель на первый элемент массива.

---





**Строковый литерал** - особая синтаксическая конструкция, которая преобразуется в статический безымянный массив символов.

```c
char a[] = "carrot"; // "carrot" преобразуется в
static char b[] = {'c', 'a', 'r', 'r', 'o', 't', '\0'};
```






- https://ru.wikipedia.org/wiki/Компилятор
- https://ru.wikipedia.org/wiki/Компоновщик
- https://ru.wikipedia.org/wiki/Исполняемый_файл
- https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format
- [Стиль оформления кода Linux](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/coding-style.rst) - отступы табом в 8 символов, что достаточно явно сигнализирует и слишком большой вложенности.
