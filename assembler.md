# assembler

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

_start:
mov $4, %eax
mov $1, %ebx
mov $mystr, %ecx
mov $8, %edx
int $0x80

mov $1, %eax
mov $0, %ebx
int $0x80
```

Сборка в исполняемую программу

    as prog1.s -o prog1.o && ld prog1.o -o prog1 && ./prog1

Исходный код из текста превращается в машинный код и данные в файле ELF перемещаемого типа. После этого выполняется связывание меток через `ld` и файл превращается в ELF исполняемого или совместно используемого типа.

Для языка ассемблера нет стандарта, кроме документации от производителя.

Разновидности

- gas - The GNU assembler
- nasm - Linux/FreeBSD
- tasm - Borland Turbo Assembler
- masm - Microsoft Assembler
- fasm - Windows
- yasm - Windows

Синтаксисы

- [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- Intel

## x86

Текстовый код переводится в двоичный один к одному. Поэтому к любой строке в коде можно обратиться через метку, которая заменится на адрес. Метки выглядят, как число или слово с двоеточием в конце. Текстовые метки попадают в таблицу меток ELF файла. Числовые метки не попадают в таблицу меток. Метки с точкой в начале имени делаются локальными явно.

Можно также размещать код в разделы ELF

- text предназначен для участка памяти, данные в котором не будут меняться
- data - для участка памяти с изменяемыми данными

Реальное применение разделов зависит от архитектуры железа. Например, раздел data может не загружаться из файла в память вообще.

Команды сборщика (pseudo op)

- `.globl mylabel1, mylabel2` - объявить перечисленные метки общедоступными
- `.string "test1", "test2"` - разместить строку c NULL в конце в объектом файле
- `.text` - разместить идущий далее код в раздел text
- `.data` - разместить идущий далее код в раздел data

```assembly
myvar:   # метка
.byte 48 # сохранить число (адрес будет $myvar)
.byte 49 # $myvar+1

othervar:
.short 50

myarray:
.byte 51, 52, 53 # массив с доступом по смещению адреса
```

Команды процессора

- перемещение значений: mov, push, pop, lea
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret

Длина в байтах для действий над операндами определяется размером регистра в операдне. Если операнд - обычное значение, то нужно явно указать длину через суффикс команды

- `movb` - 1 байт или 8 бит, byte
- `movw` - 2 байта или 16 бит, word
- `movl` - 4 байта или 32 бита, long
- `movq` - 8 байт или 64 бита, quad
- `movt` - ten

Использование адресов в командах

```
[sreg:][offset][([base][,index][,scale])]
```

Обязательно хотя бы одно значение. Для base, index или scale нужно добавлять скобки.

### Регистры

Регистры - 32-битные или 64-битные ячейки быстрой памяти в процессоре для временного хранения значений при выполнении перемещения, сложения и т.д. Назначение регистров условное, но есть общепринятые соглашения.

- EAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- ABX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- ECX — счетчик, его неявно используют некоторые команды для организации циклов.
- EDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- ESI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- EDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- ESP — указатель стека. Содержит адрес вершины стека.
- EBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

К регистрам можно обращаться частями

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

### call

Команда `call` используется для перехода по адресу в самостоятельный блок команд - **подпрограмму**.

Перед выполнением подпрограммы, после неё, а также внутри неё в начале и в конце необходимо соблюдение некоторых правил, нарушение которых приведёт к падению программы.

Перед переходом

- при необходимости сохранить значение регистров EAX, ECX, EDX в память стека командой `push`, так как подпрограмма может их использовать
- при необходимости передать подпрограмме значения командой `push`, начиная с последнего
- выполнить `call`, чтобы поместить return address перед параметрами и переместься в подпрограмму

После завершения

- очистить стек от переданных в подпрограмму значений
- восстановить из стека сохранённые значения EAX, ECX, EDX с помощью `pop`

Например, очистить стек от трёх параметров длиной по 4 байта, можно увеличив адрес указателя стека

    add $12, %esp

После завершения подпрограммы в EAX находится результат выполнения.

Пример

```assembly
.globl _start

mystr:           # добавляем метку перед строкой для обращения к ней
.string "yoyoyo!\n"

f1:

# Правила в начале подпрограммы

push %rbp        # сохраняем указатель в стек
mov  %rsp, %rbp  # копируем значение указателя стека (адрес вершина стека) в указатель базы стека

# Код подпрограммы

mov $4, %eax     # запишем 4 в EAX, что для Linux значит sys_write
mov $1, %ebx     # запишем 1 в EBX, что для Linux значит stdout процесса
mov $mystr, %ecx # в ECX запишем начало данных для вывода
mov $8, %edx     # в EDX запишем длину выводимых данных
int $0x80        # передаём управление Linux

# Правила в конце подпрограммы

mov $0, %eax     # кладём возвращаемое значение
pop %rbp         # достаём старый указатель базы и помещаем обратно в %rbp
ret              # возврат обратно в место команды call

f2:
mov $1, %eax     # sys_exit
mov $0, %ebx     # значение, которое вернёт сам процесс
int $0x80

_start:          # стандартная метка для явного указания начала команд
call f1
call f2
```



