# assembler

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

_start:
mov $4, %eax
mov $1, %ebx
mov $mystr, %ecx
mov $8, %edx
int $0x80

mov $1, %eax
mov $0, %ebx
int $0x80
```

Сборка в исполняемую программу и запуск

    as prog1.s -o prog1.o && ld prog1.o -o prog1 && ./prog1

Описание

1. Текстовый код переводится в машинные команды (опкоды со значениями) и данные в файле формата ELF перемещаемого типа
2. Запускается компоновщик ld (Link eDitor), который заменяет текстовые метки на адреса, а также может объединять несколько файлов с машинным кодом в один, получая ELF файл
    - исполняемый
    - совместно используемый (динамические библиотеки)
    - перемещаемый (статические библиотеки)

Для языка ассемблера нет стандарта, кроме документации от производителя.

Разновидности

- gas - The GNU assembler, Linux, синтаксис [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- nasm - синтаксис Intel
- yasm - переделка nasm
- fasm - свободный, использован для написания MenuetOS/KolibriOS, может обойтись без компоновщика
- tasm - Borland, не поддерживается
- masm - Microsoft, MS-DOS, Windows

## Метки

Код программы фактически является отражением будущего файла с машинными командами и данными. При запуске программы и загрузке в память к ним можно обращаться по адресу в памяти. Но адрес заранее неизвестен, поэтому в коде программы расставляются метки, которые сначала попадают в таблицу меток ELF файла, а затем комапоновщик заменяет их на рабочие адреса при создании ELF файла (статически) и/или при запуске программы (динамически).

```assembly
myvar:           # метка
.byte 48         # сохранить число (адрес будет $myvar)
.byte 49         # адрес со смещением $myvar+1

othervar:
.short 50

myarray:
.byte 51, 52, 53 # массив $myarray, $myarray+1, $myarray+2
```

Между файлами видны только метки с глобальным статусом. Точка в начале имени явно определяет метку, как локальную.

## Разделы

Участки кода программы можно распределять в разные разделы файла ELF, чтобы при запуске программы они загружались в разные виды памяти. Для этого перед участками кода ставятся команды сборщика

```assembly
.data # поместить всё, что идёт дальше, в раздел data
var1:
.byte 10

var2:
.string "text1\n"

.text # поместить всё, что идёт дальше, в раздел text
mov $4, %eax

.data # возможно повторение команды
var3:
.byte 1, 2, 3
```

Назначение

- text - для постоянных данных (для команд процессора и констант, попытка изменения в процессе работы программы приведёт к падению)
- data - для данных, которые программа может изменить в процессе работы (размещение здесь команд может вызвать ошибку безопасности)

Если не использовать разделы, то всё попадает в раздел text.

## Команды сборщика

- `.text` - помещение кода в раздел text
- `.data` - помещение кода в раздел data
- `.byte` - сохранить значения в файле программы
- `.string` - сохранить строки с нулевым байтом (обозначает конец строки) в файле программы
- `.globl` - сделать метки глобальными

## Команды процессора

- перемещение буквальных значений, адресов или значений регистров
    - mov - в другой регистр
    - push - в стек (также смещает указатель стека)
    - pop - из стека в регистр
    - lea - адрес в регистр (получаем указатель)
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret
- enter - создать кадр стека
- leave - обратить действие enter
- int - отправка сигнала прерывания

Прерывание - сигнал от оборудования или программы для обработчика прервываний, чтобы уведомить процессор о необходимости каких-то действий.

При выполнений команд длина учитывается в байтах. По умолчанию длина определяется по регистру. Ножелательно явно указать длину через имя команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита

## Адреса

Синтаксис адресов `[sreg:][смещение][([база][,индекс][,множитель])]`. Обязательно хотя бы одно значение. Для base, index или scale требуются скобки.

```assembly
mov (%rbx), %rax       # значение по адресу в регистре RBX
mov 16(%rbx), %rax     # со смещением на 16 байт вперёд
mov %rbx, myvar(,1)    # значение из регистра в память по адресу myvar + 1 байт
mov %cl, (%rsi,%rax,1) # адрес 1 байта после суммы адресов из регистров
```

## Регистры

32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- RAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- RBX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- RCX — счетчик, его неявно используют некоторые команды для организации циклов.
- RDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- RSI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- RDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- RSP — указатель стека, указывает на вершину стека.
- RBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

Для частичного обращения к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

## call

Функции в ассемблере делаются с помощью **подпрограмм** - метки с командами. При этом в памяти временно используется пространство в виде стека, который заполняется в сторону уменьшения адресов.

Случайный пример

```
     ┌───────────────────────┐
 ▲   │    сохранённый RAX    │
 │ а ├───────────────────────┤
 │ д │ переданное значение 3 │
 │ р ├───────────────────────┤
 │ е │ переданное значение 2 │
 │ с ├───────────────────────┤
 │ а │ переданное значение 1 │
 │   ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │
 │   ├───────────────────────┤
 │   │     переменная 2      │
 │ с ├───────────────────────┤
 │ т │     переменная 3      │
 │ е ├───────────────────────┤
 │ к │    сохранённый RBX    │
 │   ├───────────────────────┤
 ▼   │    сохранённый RDI    │
     └───────────────────────┘
```

При использовании подпрограмм есть правила.

### Перед переходом

Если уже используются RAX, RCX, RDX, то сохранить нужные в стек

    push %rax
    push %rcx
    push %rdx

Сохранить в стек произвольные значения, которые будут использоваться в подпрограмме

    push $8
    push $mystr

Перейти к первой команде подпрограммы по метке, сохранив адрес возврата в стек

    call f1

### После перехода

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     ├───────────────────────┤
     │    адрес возврата     │
     └───────────────────────┘
```

Сохранить в стек старое значение RBP, чтобы потом востановить

    push %rbp

Записать RSP в RBP, чтобы через смещение адреса искать в стеке переданные в подрограмму значения и переменные

    mov %rsp, %rbp

При необходимости выделить в стеке пространство под переменные, например, увеличением RSP на сумму размера переменных

    sub $4, %rsp # 4 байта для переменных

Сохранить RBX, RDI, RSI в стек, если они будут использоваться для других задач

    push %rbx
    push %rdi
    push %rsi

### Перед возвратом

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │  24($rbp)
     ├───────────────────────┤
     │ переданное значение 1 │  16($rbp)
     ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │  -4($rbp)
     ├───────────────────────┤
     │    сохранённый RDI    │
     └───────────────────────┘
```

Поместить результат выполнения в RAX

    mov $0, %rax

Восстановить RBX, RDI, RSI из стека в обратном порядке

    pop %rsi
    pop %rdi
    pop %rbx

Если выделялось пространство под переменные, то освободить его уменьшением RSP или переносом RBP в RSP (так как RBP был равнозначен RSP до выделения пространства под переменные)

    mov %rbp, %rsp

Восстановить старое значение RBP из стека

    pop %rbp

Выполнить возврат из подпрограммы и удаление адреса возврата из стека

    ret

### После возврата

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     └───────────────────────┘
```

Очистить стек от переданных в подпрограмму значений, например, увеличив указатель стека на сумму размера значений

    add $16, %rsp

Восстановить из стека сохранённые значения RAX, RCX, RDX в обратном порядке

    pop %rdx
    pop %rcx
    pop %rax

### Пример

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

str2:
.string "hello world?\n"

f1:
push %rbp
mov %rsp, %rbp

mov $4, %rax        # запишем 4 в RAX, в Linux значит sys_write
mov $1, %rbx        # запишем 1 в RBX, в Linux значит stdout процесса
mov 16(%rbp), %rcx  # берём значение из стека смещением адреса (в RCX начало данных для sys_write)
mov 24(%rbp), %rdx  # в RDX длина строки для вывода
int $0x80           # 0x80 прерывание обрабатывает Linux для системных вызовов

mov $0, %rax
pop %rbp
ret

f2:
mov $1, %rax        # sys_exit
mov $0, %rbx        # значение возврата процесса
int $0x80

_start:
push $8             # длина строки
push $mystr         # адрес начала строки
call f1
add $16, %rsp

push $14
push $str2
call f1
add $16, %rsp

call f2
```

