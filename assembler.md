# assembler

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

_start:
mov $4, %eax
mov $1, %ebx
mov $mystr, %ecx
mov $8, %edx
int $0x80

mov $1, %eax
mov $0, %ebx
int $0x80
```

Сборка в исполняемую программу и запуск

    as prog1.s -o prog1.o
    ld prog1.o -o prog1
    ./prog1

Описание

1. Сборщик выполняет команды сборщика, переводит команды процессора в машинный формат, состоящий из кодов операций, и сохраняет результат в файл ELF перемещаемого типа
2. Компоновщик ld (Link eDitor) заменяет текстовые метки на адреса и объединяет несколько ELF в один, получая в итоге
    - исполняемый ELF
    - совместно используемый ELF (динамические библиотеки)
    - перемещаемый ELF (статические библиотеки)
 3. Запуск программы через системные вызовы fork и execve
    - fork полностью копирует родительский процесс памяти
    - execve вызывает загрузчик программ

Для языка ассемблера нет стандарта, кроме документации от производителя.

Разновидности

- gas - The GNU assembler, Linux, синтаксис [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- nasm - синтаксис Intel
- yasm - переделка nasm
- fasm - свободный, использован для написания MenuetOS/KolibriOS, может обойтись без компоновщика
- tasm - Borland, не поддерживается
- masm - Microsoft, MS-DOS, Windows

## Метки

Код программы фактически является отражением будущего файла с машинными командами и данными. При запуске программы всё это загружается в память и становится адресуемым пространством. Но адрес заранее неизвестен, поэтому в коде программы расставляются метки, которые позже попадают в таблицу меток в файле ELF и заменяются компоновщиком на рабочие адреса: при создании нового ELF (статически) и/или при запуске программы (динамически).

```assembly
myvar:           # метка
.byte 48         # сохранить число (адрес будет $myvar)
.byte 49         # адрес со смещением $myvar+1

othervar:
.short 50

myarray:
.byte 51, 52, 53 # массив $myarray, $myarray+1, $myarray+2
```

Между файлами видны только метки с глобальным статусом. Точка в начале имени явно определяет метку, как локальную.

Метка `_start` является точкой входа в программу по умолчанию. Для изменения используется опция компоновщика `-e`.

## Разделы

Участки кода программы можно распределять в разные разделы файла ELF, чтобы при запуске программы они загружались в разные виды памяти. Для этого перед участками кода ставятся команды сборщика

```assembly
.data # поместить всё, что идёт дальше, в раздел data
var1:
.byte 10

var2:
.string "text1\n"

.text # поместить всё, что идёт дальше, в раздел text
mov $4, %eax

.data # возможно повторение команды
var3:
.byte 1, 2, 3
```

Назначение

- text - для постоянных данных (для команд процессора и констант, попытка изменения в процессе работы программы приведёт к падению)
- data - для данных, которые программа может изменить в процессе работы (размещение здесь команд может вызвать ошибку безопасности)

Если не использовать разделы, то всё попадает в раздел text.

Просмотреть разделы

    readelf -lW prog1

## Команды сборщика

- `.text` - помещение кода в раздел text
- `.data` - помещение кода в раздел data
- `.byte` - сохранить значения в файле программы
- `.string` - сохранить строки с нулевым байтом (обозначает конец строки) в файле программы
- `.globl` - сделать метки глобальными

## Команды процессора

- перемещение буквальных значений, адресов или значений регистров
    - mov - в другой регистр
    - push - в стек (также смещает указатель стека)
    - pop - из стека в регистр
    - lea - адрес в регистр (получаем указатель)
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret
- enter - создать кадр стека
- leave - обратить действие enter
- int - отправка сигнала прерывания

**Прерывание** - сигнал от оборудования или программы для обработчика прервываний, чтобы уведомить процессор о необходимости каких-то действий.

При выполнений команд длина учитывается в байтах. По умолчанию длина определяется по регистру. Ножелательно явно указать длину через имя команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита

## Адреса

Синтаксис адресов `[sreg:][смещение][([база][,индекс][,множитель])]`. Обязательно хотя бы одно значение. Для base, index или scale требуются скобки.

```assembly
mov (%rbx), %rax       # значение по адресу в регистре RBX
mov 16(%rbx), %rax     # со смещением на 16 байт вперёд
mov %rbx, myvar(,1)    # значение из регистра в память по адресу myvar + 1 байт
mov %cl, (%rsi,%rax,1) # адрес 1 байта после суммы адресов из регистров
```

## Регистры

32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- RAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- RBX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- RCX — счетчик, его неявно используют некоторые команды для организации циклов.
- RDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- RSI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- RDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- RSP — указатель стека, указывает на вершину стека.
- RBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

Для частичного обращения к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

## call

Подпрограмма - отдельный набор команд, к которому можно обращаться через вызов с указанием метки. При использовании подпрограмм в памяти временно выделяется пространство в виде стека, которое заполняется в сторону уменьшения адреса.

Пример

```
     ┌───────────────────────┐
 ▲   │    сохранённый RAX    │
 │ а ├───────────────────────┤
 │ д │ переданное значение 3 │
 │ р ├───────────────────────┤
 │ е │ переданное значение 2 │
 │ с ├───────────────────────┤
 │ а │ переданное значение 1 │
 │   ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │
 │   ├───────────────────────┤
 │   │     переменная 2      │
 │ с ├───────────────────────┤
 │ т │     переменная 3      │
 │ е ├───────────────────────┤
 │ к │    сохранённый RBX    │
 │   ├───────────────────────┤
 ▼   │    сохранённый RDI    │
     └───────────────────────┘
```

При использовании подпрограмм есть правила.

### 1. Перед вызовом

Если уже используются RAX, RCX, RDX, то сохранить нужные в стек

    push %rax
    push %rcx
    push %rdx

Сохранить в стек произвольные значения, которые будут использоваться в подпрограмме

    push $8
    push $mystr

Перейти к первой команде подпрограммы по метке, сохранив адрес возврата в стек

    call f1

### 2. В начале подпрограммы

Что в стеке

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     ├───────────────────────┤
     │    адрес возврата     │
     └───────────────────────┘
```

Сохранить в стек старое значение RBP, чтобы потом востановить

    push %rbp

Записать RSP в RBP, чтобы через смещение адреса искать в стеке переданные в подрограмму значения и переменные

    mov %rsp, %rbp

При необходимости выделить в стеке пространство под переменные, например, увеличением RSP на сумму размера переменных

    sub $4, %rsp # выделили 4 байта для переменных

Сохранить RBX, RDI, RSI в стек, если они будут использоваться для других задач

    push %rbx
    push %rdi
    push %rsi

### 3. В конце подпрограммы

Что в стеке

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │  24($rbp)
     ├───────────────────────┤
     │ переданное значение 1 │  16($rbp)
     ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │  -4($rbp)
     ├───────────────────────┤
     │    сохранённый RDI    │
     └───────────────────────┘
```

Поместить результат выполнения в RAX

    mov $0, %rax

Восстановить RBX, RDI, RSI из стека в обратном порядке

    pop %rsi
    pop %rdi
    pop %rbx

Если выделялось пространство под переменные, то освободить его уменьшением RSP или переносом RBP в RSP (так как RBP был равнозначен RSP до выделения пространства под переменные)

    mov %rbp, %rsp

Восстановить старое значение RBP из стека

    pop %rbp

Выполнить возврат из подпрограммы и удаление адреса возврата из стека

    ret

### 4. После возврата

Что в стеке

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     └───────────────────────┘
```

Очистить стек от переданных в подпрограмму значений, например, увеличив указатель стека на сумму размера значений

    add $16, %rsp

Восстановить в обратном порядке сохранённые ранее в стек значения RAX, RCX, RDX

    pop %rdx
    pop %rcx
    pop %rax

### Пример подпрограммы

```assembly
.globl _start

.data

mystr:
.string "yoyoyo!\n"

str2:
.string "world?\n"

.text

f1:
push %rbp
mov %rsp, %rbp

mov $4, %rax
mov $1, %rbx
mov 16(%rbp), %rcx # читаем переданное в подпрограмму значение смещением адреса
mov 24(%rbp), %rdx # второе значение
int $0x80

mov $0, %rax
pop %rbp
ret

f2:                # другая подпрограмма
mov $1, %rax
mov $0, %rbx
int $0x80

_start:
push $8            # передаём значение в подпрограмму
push $mystr        # передаём второе значение
call f1
add $16, %rsp

push $7
push $str2
call f1            # вызов подпрограммы с другими значениями
add $16, %rsp

call f2
```

Сигнал прерывания `0x80` означает сигнал для Linux обработать системный вызов. Содержимое регистров определяет системный вызов и его особенности

- 4 в RAX означает системный вызов sys_write
- 1 в RBX означает stdout процесса
- из RCX будет считано начало данных для sys_write
- в RDX длина строки для вывода

Во второй подпрограмме

- 1 в RAX означает системный вызов sys_exit
- в RBX значение возврата самой программы

## Динамическая компоновка

При компоновке в заголовок INTERP файла ELF может быть указан путь до динамического компоновщика. Это отдельная программа, которая загружается в память перед нашей программой и ищет метки, которые находятся в динамических библиотеках. Затем она загружает библиотеки в память и заменяет метки на адреса. Обычно в библиотеки выносится часто используемый функционал программ, вроде форматированного вывода текста.

```assembly
.globl _start

.data

mystr:
.string "yoyoyo!"

.text

_start:

leaq	mystr(%rip), %rax
movq	%rax, %rdi
call	puts@PLT

mov $1, %rax
mov $0, %rbx
int $0x80
```

Сборка и компоновка

    as prog1.s -o prog1.o
    ld prog1.o --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -lc -o prog1

Отобразить связи с библиотеками

    ldd prog1

С помощью переменной окружения LD_PRELOAD можно указать библиотеку, которая загрузится раньше других, таким образом подменив некоторый функционал из других библиотек. Например, `uncompress.so` добавит прозрачное разжатие при чтении данных.

Динамический компоновщик `ld-linux-x86-64.so.2` является и исполняемым файлом и динамической библиотекой. Например, он содержит malloc. Но при запуске его malloc может быть заменён на тот, что в библиотеке libc.

### Пример динамической библиотеки

```assembly
.text

.globl print, exit

print:
push %rbp
mov %rsp, %rbp

mov $4, %rax
mov $1, %rbx
mov 16(%rbp), %rcx
mov 24(%rbp), %rdx
int $0x80

mov $0, %rax
pop %rbp
ret

exit:
mov $1, %rax
mov $0, %rbx
int $0x80
```

Сборка и компоновка

    as things.s -o things.o
    ld -shared things.o -o libthings.so

Имя динамических библиотек должно начинаться на `lib` и заканчиваться на `.so`.

Программа, использующая библиотеку

```assembly
.globl _start, print, exit

.data

str1:
.string "yoyoyo!\n"

str2:
.string "hello world?\n"

.text

_start:

push $8
push $str1
call print
add $16, %rsp

push $14
push $str2
call print
add $16, %rsp

call exit

```

Сборка, компоновка и запуск

    as prog1.s -o prog1.o
    ld prog1.o -L . -l mydyn --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o prog1
    LD_LIBRARY_PATH=. ./prog1

Опции компоновщика

- `-L` - путь поиска библиотек
- `-l` - имя библиотеки

Чтобы не размещать библиотеку в системные папки можно с помощью переменной LD_LIBRARY_PATH временно поменять путь их поиска.

## Загрузчик программ

При выполнении execve (подпрограмма из статической библиотеки libc) происходит

- разные проверки (права, необходимый объём памяти и т.д.)
- загрузка программы в оперативную память (вместо реальной загрузки происходит связывание файла с виртальной памятью и загрузка по мере необходимости)
- копирование в память переданных аргументов
- подготовка регистров (например, указателя на стек)
- перемещение в точку входа программы

Загрузка в память заменяет процесс, который был скопирован до этого командой fork. А также заново создаётся стек, куча (heap) и раздел изменяемых данных.




## Микрокод

Часть сложных команд процессора могут быть сделаны не на схеме, а в виде микропрограммы для устройства (микрокод), управляющего процессором. В основном это относится к процессорам архитектуры CISC, а в RISC - наоборот сохраняется минимальный набор простых команд, выполненных на схеме.

Команды на схеме работают быстрее и лучше для параллельных вычислений. Также программы часто используют простые операции.


