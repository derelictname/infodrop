# assembler

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

_start:
mov $4, %eax
mov $1, %ebx
mov $mystr, %ecx
mov $8, %edx
int $0x80

mov $1, %eax
mov $0, %ebx
int $0x80
```

Сборка в исполняемую программу и запуск

    as prog1.s -o prog1.o && ld prog1.o -o prog1 && ./prog1

Сначала текстовый код превращается в машинные команды (опкоды со значениями) и данные в файле формата ELF перемещаемого типа. Затем с помощью ld (компоновщик, связыватель ссылок, Link eDitor) один или несколько ELF перемещаемого типа соединяются в один ELF исполняемого, совместно используемого (динамические библиотеки) или снова перемещаемого типа (статические библиотеки).

Для языка ассемблера нет стандарта, кроме документации от производителя.

Разновидности

- gas - The GNU assembler, Linux, синтаксис [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- nasm - синтаксис Intel
- yasm - переделка nasm
- fasm - свободный, использован для написания MenuetOS/KolibriOS, может обойтись без компоновщика
- tasm - Borland, не поддерживается
- masm - Microsoft, MS-DOS, Windows

## Метки

При переводе программы в ELF файл и запуске программы команды и данные в нём являются адресуемыми местами, на которые можно ссылаться в коде программы. Чтобы знать адрес используются метки в коде программы, которые попадают в таблицу меток ELF и заменяются компоновщиком на адреса в памяти: сразу, либо при запуске программы. Это называется статическое и динамическое связывание (например, с библиотекой).

```assembly
myvar:           # метка
.byte 48         # сохранить число (адрес будет $myvar)
.byte 49         # адрес со смещением $myvar+1

othervar:
.short 50

myarray:
.byte 51, 52, 53 # массив $myarray, $myarray+1, $myarray+2
```

Между файлами видны только метки с глобальным статусом. Точка в начале имени явно определяет метку локальной.

## Разделы памяти

При запуске программы она помещается в оперативную память. Со стороны железа память может иметь разное назначение: постоянные данные, изменяемые данные. Для помещение участка кода в конкретную память перед ним ставится команда сборщика

- `.text` - для постоянных данных (по умолчанию, для команд процессора и констант, изменение приведёт к падению)
- `.data` - для изменяемых данных (может не загружаться в память вообще, размещение здесь команд может вызвать ошибку безопасности)

## Команды сборщика

- `.globl mylabel1, mylabel2` - сделать метки глобальными
- `.string "test1", "test2"` - разместить массив символов с NULL в конце

## Команды процессора

- перемещение буквальных значений, адресов или значений регистров
    - mov - в другой регистр
    - push - в стек (также смещает указатель стека)
    - pop - из стека в регистр
    - lea - адрес в регистр (получаем указатель)
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret
- enter - создать кадр стека
- leave - обратить действие enter
- int - программный вызов обработчика прерываний (смена контекста работы процессора)

При выполнений команд длина учитывается в байтах. По умолчанию длина определяется по регистру. Ножелательно явно указать длину через имя команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита
- `movt` - ten

## Адреса

Синтаксис адресов `[sreg:][смещение][([база][,индекс][,множитель])]`. Обязательно хотя бы одно значение. Для base, index или scale требуются скобки.

```assembly
mov (%rbx), %rax       # значение по адресу в регистре RBX
mov 16(%rbx), %rax     # со смещением на 16 байт вперёд
mov %rbx, myvar(,1)    # значение из регистра в память по адресу myvar + 1 байт
mov %cl, (%rsi,%rax,1) # адрес 1 байта после суммы адресов из регистров
```

## Регистры

32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- RAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- RBX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- RCX — счетчик, его неявно используют некоторые команды для организации циклов.
- RDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- RSI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- RDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- RSP — указатель стека, указывает на вершину стека.
- RBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

Для частичного обращения к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

## call

Функции в ассемблере делаются с помощью **подпрограмм** - метки с командами. При этом в памяти временно используется пространство в виде стека, который заполняется в сторону уменьшения адресов.

Пример

```
     ┌───────────────────────┐
 ▲   │    сохранённый RAX    │
 │ а ├───────────────────────┤
 │ д │ переданное значение 3 │
 │ р ├───────────────────────┤
 │ е │ переданное значение 2 │
 │ с ├───────────────────────┤
 │ а │ переданное значение 1 │
 │   ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │
 │   ├───────────────────────┤
 │   │     переменная 2      │
 │ с ├───────────────────────┤
 │ т │     переменная 3      │
 │ е ├───────────────────────┤
 │ к │    сохранённый RBX    │
 │   ├───────────────────────┤
 ▼   │    сохранённый RDI    │
     └───────────────────────┘
```

При использовании подпрограмм есть правила.

### Перед переходом

Если использовались регистры RAX, RCX, RDX, то сохранить их в стек

    push %rax
    push %rcx
    push %rdx

Сохранить в стек произвольные значения, которые будут нужны в подпрограмме

    push $8
    push $mystr

Перейти к первой команде подпрограммы по метке, сохранив адрес возврата в стек

    call f1

### После перехода

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 3 │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     ├───────────────────────┤
     │    адрес возврата     │
     └───────────────────────┘
```

Сохраняем в стек старое значение RBP, чтобы потом востановить

    push %rbp

Записываем RSP в RBP, чтобы через смещение адреса искать в стеке переданные в подрограмму значения и переменные

    mov %rsp, %rbp

При необходимости выделяем в стеке пространство под переменные, например, увеличением RSP на размер переменных

    sub $4, %rsp # 4 байта для переменных

Сохранить регистры RBX, RDI, RSI в стек, если они будут использоваться для других задач

    push %rbx
    push %rdi
    push %rsi

### Перед завершением

```
     ┌───────────────────────┐
     │ переданное значение 3 │  32($rbp)
     ├───────────────────────┤
     │ переданное значение 2 │  24($rbp)
     ├───────────────────────┤
     │ переданное значение 1 │  16($rbp)
     ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │  -4($rbp)
     ├───────────────────────┤
     │    сохранённый RDI    │
     └───────────────────────┘
```

Поместить результат выполнения в RAX

    mov $0, %rax

Восстановить регистры RBX, RDI, RSI из стека в обратном порядке

    pop %rsi
    pop %rdi
    pop %rbx

Если выделялось пространство под переменные, то освободить его уменьшением RSP или переносом RBP в RSP (так как RBP был равнозначен RSP до выделения пространства под переменные)

    mov %rbp, %rsp

Восстановить старое значение RBP из стека

    pop %rbp

Выполнить команду возврата из подпрограммы и удаления адреса возврата из стека

    ret

### После завершения

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │ переданное значение 3 │
     ├───────────────────────┤
     │ переданное значение 2 │
     ├───────────────────────┤
     │ переданное значение 1 │
     └───────────────────────┘
```

Очистить стек от переданных в подпрограмму значений, например, увеличив указатель стека

    add $16, %rsp

Восстановить из стека сохранённые значения RAX, RCX, RDX в обратном порядке

    pop %rdx
    pop %rcx
    pop %rax

После завершения подпрограммы в RAX будет находится результат выполнения.

### Пример

```assembly
.globl _start

mystr:
.string "yoyoyo!\n" # сохранить в файле программы текст с NULL в конце

str2:
.string "hello world?\n"

f1:
push %rbp
mov %rsp, %rbp

mov $4, %rax        # запишем 4 в RAX, в Linux значит sys_write
mov $1, %rbx        # запишем 1 в RBX, в Linux значит stdout процесса
mov 16(%rbp), %rcx  # берём значение из стека смещением адреса (в RCX начало данных для sys_write)
mov 24(%rbp), %rdx  # в RDX длина строки для вывода
int $0x80           # 0x80 прерывание обрабатывает Linux для системных вызовов

mov $0, %rax
pop %rbp
ret

f2:
mov $1, %rax        # sys_exit
mov $0, %rbx        # значение возврата процесса
int $0x80

_start:
push $8             # длина строки
push $mystr         # адрес начала строки
call f1
add $16, %rsp

push $14
push $str2
call f1
add $16, %rsp

call f2
```


