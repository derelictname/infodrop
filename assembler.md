# assembler

```assembly
.globl _start

mystr:
.string "yoyoyo!\n"

_start:
mov $4, %eax
mov $1, %ebx
mov $mystr, %ecx
mov $8, %edx
int $0x80

mov $1, %eax
mov $0, %ebx
int $0x80
```

Сборка в исполняемую программу

    as prog1.s -o prog1.o && ld prog1.o -o prog1 && ./prog1

Сначала текстовый код превращается в двоичный код и данные внутри ELF перемещаемого типа. Затем с помощью ld (компоновщик, связыватель ссылок, Link eDitor) один или несколько ELF перемещаемого типа соединяются в один ELF исполняемого, совместно используемого (динамические библиотеки) или снова перемещаемого типа (статические библиотеки).

Для языка ассемблера нет стандарта, кроме документации от производителя.

Разновидности

- gas - The GNU assembler
- nasm - Linux/FreeBSD
- tasm - Borland Turbo Assembler
- masm - Microsoft Assembler
- fasm - Windows
- yasm - Windows

Синтаксисы

- [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- Intel

## x86

Текст кода переводится в двоичный код в файле один к одному. Каждая строка является адресуемым участком в памяти при запуске программы. Но чтобы знать адрес, нужно расставлять метки в коде.

Метки выглядят, как слово или число с двоеточием в конце. После них идут команды или данные, к которым можно будет обратиться по имени метки. Числовые метки не попадают в таблицу меток. Точка в начале имени делает метку локальной явно.

Позже метки заменяются на реальные адреса компоновщиком сразу (статическая компоновка), либо во время запуска программы (динамическая компоновка).

```assembly
myvar:   # метка
.byte 48 # сохранить число (адрес будет $myvar)
.byte 49 # адрес со смещением $myvar+1

othervar:
.short 50

myarray:
.byte 51, 52, 53 # массив с доступом по смещению
```

При запуске программы код размещается в определённые участки памяти: постоянную память, изменяемую и др. Для размещения кода в конкретный участок используются команды

- `.text` - для постоянных данных (команды процессора, константы)
- `.data` - для изменяемых данных

Реальное применение разделов зависит от архитектуры железа. Например, раздел data может не загружаться из файла в память вообще. Размещение команд процессора в data может привести к ошибке безопасности. Попытка изменить text обрушит программу. Без явного указания раздела всё разместится в text, но это зависит от конкретного сборщика.

Команды сборщика (pseudo op)

- `.globl mylabel1, mylabel2` - сделать метки видимыми в других файлах (или из них)
- `.string "test1", "test2"` - разместить в объектом файле строки, оканчивающиеся на NULL

Команды процессора

- перемещение значений: mov, push, pop, lea
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret

При выполнений команд длина изменяемых данных измеряется в байтах и определяется размером регистра в одном из операндов (а размер регистра - разрядностью процессора). Но, если операнд - обычное значение, то желательно явно указать длину через суффикс команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита
- `movt` - ten

Синтаксис адреса

```
[sreg:][offset][([base][,index][,scale])]
```

Обязательно хотя бы одно значение. Для base, index или scale нужно добавлять скобки.


**Регистры** - 32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- EAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- ABX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- ECX — счетчик, его неявно используют некоторые команды для организации циклов.
- EDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- ESI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- EDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- ESP — указатель стека. Содержит адрес вершины стека.
- EBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

Для частичного обращения к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

## Подпрограммы

Команда `call` используется для перехода по адресу в самостоятельный блок команд - **подпрограмму**.

Перед выполнением подпрограммы, после неё, а также внутри неё в начале и в конце необходимо соблюдение некоторых правил, нарушение которых приведёт к падению программы.

Перед переходом

- при необходимости сохранить значение регистров EAX, ECX, EDX в память стека командой `push`, так как подпрограмма может их использовать
- при необходимости передать подпрограмме значения командой `push`, начиная с последнего
- выполнить `call`, чтобы поместить return address перед параметрами и переместься в подпрограмму

После завершения

- очистить стек от переданных в подпрограмму значений
- восстановить из стека сохранённые значения EAX, ECX, EDX с помощью `pop`

Например, очистить стек от трёх параметров длиной по 4 байта, можно увеличив адрес указателя стека

    add $12, %esp

После завершения подпрограммы в EAX находится результат выполнения.

Пример

```assembly
.globl _start

mystr:           # добавляем метку перед строкой для обращения к ней
.string "yoyoyo!\n"

f1:

# Правила в начале подпрограммы

push %rbp        # сохраняем указатель в стек
mov  %rsp, %rbp  # копируем значение указателя стека (адрес вершина стека) в указатель базы стека

# Код подпрограммы

mov $4, %eax     # запишем 4 в EAX, что для Linux значит sys_write
mov $1, %ebx     # запишем 1 в EBX, что для Linux значит stdout процесса
mov $mystr, %ecx # в ECX запишем начало данных для вывода
mov $8, %edx     # в EDX запишем длину выводимых данных
int $0x80        # передаём управление Linux

# Правила в конце подпрограммы

mov $0, %eax     # кладём возвращаемое значение
pop %rbp         # достаём старый указатель базы и помещаем обратно в %rbp
ret              # возврат обратно в место команды call

f2:
mov $1, %eax     # sys_exit
mov $0, %ebx     # значение, которое вернёт сам процесс
int $0x80

_start:          # стандартная метка для явного указания начала команд
call f1
call f2
```



