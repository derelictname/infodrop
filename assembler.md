# asm

```assembly
.globl _start

text1: .string "yoyoyo!\n"
delay: .quad 10, 0

_start:
mov $1, %rax     # номер системного вызова (sys_write)
mov $1, %rdi     # номер файлового дескриптора (stdout)
mov $text1, %rsi # адрес начала данных
mov $8, %rdx     # длина данных
syscall          # выполнить системный вызов с учётом значений в регистрах

mov $35, %rax    # номер системного вызова (sys_nanosleep)
mov $delay, %rdi # аргумент системного вызова (значение 10 секунд, 0 наносекунд)
mov $0, %rsi     # указатель для записи оставшегося времени в случае прерывания
syscall          # выполнить системный вызов с учётом значений в регистрах

mov $60, %rax    # sys_exit
mov $0, %rdi     # значение выхода программы
syscall
```

Код программы состоит команд самого ассемблера, команд процессора и меток.

Например, `.quad` и `.string` - это **команды ассемблера**, они выполняются при сборке программы и сохраняют произвольное значение в тело программы для каких-либо задач во время работы программы.

**Команды процессора** переводятся в свой машинные эквиваленты - опкоды или коды операции. Например, `mov` или `syscall` - это текстовое представление машинной команды процессора, которая в готовой программе превращается в байт, обозначающий эту команду в данной архитектуре процессора. После байта могут идти ещё байты, обозначающие операнды - что или откуда скопировать и куда это скопировать. Процессор читает из памяти программы эти команды по очереди и выполняет.

Для обращения к адресу в памяти используются **метки**, так как они превращаются в заранее известный адрес: сначала при компоновке, а при запуске с учётом смещения к началу выделенной программе памяти. `_start` всегда используется для обозначения начала команд процессора - то, откуда начинать выполнение программы. `text1` или `delay` - это произвольные имена для обращения к значениям рядом с ними в командах процессора, таких как `mov`, `jmp` или `call` и других.

Запускаем сборщик, который выполняет команды сборщика, переводит команды процессора в байты кодов операций и сохраняет результат в файл ELF перемещаемого типа

    as prog1.s -o prog1.o

Компоновка

    ld prog1.o -o prog1

Компоновщик ld (Link eDitor) заменяет текстовые метки на адреса и может также объединять несколько ELF в один. На выходе мы получаем

    - исполняемый ELF
    - совместно используемый ELF (динамические библиотеки)
    - перемещаемый ELF (статические библиотеки)

Запуск

    ./prog1

Любая программа запускается через системные вызовы fork и exec
  - fork создаёт ещё один процесс с копией памяти исходного
  - exec вызывает загрузчик программ, который вместо второго процесса загружает из файла другую программу

Прочитать программу и отобразить в виде ассемблера

    objdump -d prog1

Для языка ассемблера нет стандарта, кроме документации от производителя процессора, например, для наиболее распространённой архитектуры процессора - Intel x86-64.

## Метки

Расставляются в коде программы, попадают в таблицу меток файла ELF и заменяются на адреса при компоновке (статическая компоновка) и дополнительно могут и при запуске программы (динамическая компоновка) с помощью динамического компоновщика, который выполняется перед нашей программой.

Метки обозначаются двоеточием в конце имени.

```assembly
myvar1:
.byte 255           # значение по адресу $myvar1
.byte 0b10101010    # $myvar1 + 1

myvar2:
.word 0x310a
.word 0x320a        # $myvar2 + 2, потому что сами значения по 2 байта

myvar3:
.quad 0x32ac68fce170539f
.long 0x18e458d2    # в long умещается 64-битный адрес

myarray:
.byte 56, 32, 170   # массив $myarray, $myarray + 1, $myarray + 2

.globl _start       # определяем глобальные метки

_start:             # точка входа в программу по умолчанию
mov $60, %rax
mov $0, %rdi
syscall
```

При компоновке нескольких ELF в один между ними видны только глобальные метки. Точка в начале имени делает метку локальной явно. Числовые метки всегда локальные. Для работы программы метка `_start` должна быть обьявлена, как глобальная.

## Разделы

Код программы распределяется в разные разделы в соответствии с назначением. Сначала он попадает в раздел файла ELF: text, data, rodata, bss. При запуске программы разделы загружаются в такую же область памяти процесса. Разместить код в конкретный раздел можно командой сборщика.

```assembly
.data                   # поместить код ниже в data

delay: .quad 3, 0
text1: .string "hello\n"

.text                   # поместить код ниже в text

_start:
mov $35, %rax
mov $delay, %rdi
mov $0, %rsi
syscall

mov $60, %rax
mov $0, %rdi
syscall

.data                   # снова data

array1: .byte 1, 2, 3
```

Описание разделов

- text - используется для команд процессора и констант. Попытка изменения text в запущенном процессе приведёт к падению программы. Раздел по умолчанию.
- data - для данных с возможностью изменения (записи). Размещение здесь команд может вызвать ошибку безопасности.
- rodata - для данных без изменения (только для чтения).
- bss - для заранее не заданных данных (пустые переменные).

Пример расположения разделов в запущенной программе (процессе)

```
адреса ячеек памяти
                 ┌────────────────────────┐
  0x7fff3fedd7a8 │       значение 1       │
                 ├────────────────────────┤
  0x7fff3fedd7a0 │       значение 2       │
                 ├────────────────────────┤
  0x7fff3fedd798 │       значение 3       │
                 ├────────────────────────┤ ◄── стопка (stack)
  0x7fff3fedd790 │       значение 4       │
                 ├────────────────────────┤
  0x7fff3fedd780 │       значение 5       │
                 ├────────────────────────┤
  0x7fff3fedd778 │       значение 6       │
                 ├────────────────────────┤
       ...       │                        │
                 │       куча (heap)      │
                 │                        │
                 ├────────────────────────┤
                 │                        │
                 │          bss           │
                 │                        │
                 ├────────────────────────┤
                 │                        │
                 │          data          │
                 │                        │
                 ├────────────────────────┤
                 │                        │
                 │          text          │
                 │                        │
                 └────────────────────────┘
```

Посмотреть разделы в ELF файле

    readelf -lW prog1

Посмотреть распределение памяти процесса через procfs

    less /proc/$(pidof prog1)/maps

Посмотреть распределение памяти процесса через gdb

    info proc mappings

## Команды сборщика

- `.text` - размещение кода в раздел text
- `.data` - размещение кода в раздел data
- `.byte` - записать произвольные значения в теле программы
- `.string` - записать строки в тело программы (к строкам добавляется нулевой байт, что обозначает конец строки)
- `.globl` - сделать перечисленные метки глобальными

## Команды процессора

- копирование буквальных значений, адресов или значений регистров
    - mov - в другой регистр
    - push - в стек (также уменьшает указатель стека)
    - pop - из стека в регистр
    - lea - взять адрес и скопировать (получаем указатель)
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret
- enter - создать кадр стека
- leave - обратить действие enter
- syscall - выполнение системного вызова

При выполнений команд длина копируемого значения учитывается в байтах. По умолчанию длина определяется по регистру в операнде, но желательно делать это явно через имя команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита

В архитектуре x86 для системных вызовов используется программное прерывание `int 0x80`, но из-за разности привелегий процесса и обработчика команды процессор делал много лишний действий для переноса данных в стек обработчика. В x86-64 появилась команда `syscall`, которая быстро переходит на уровень привелегий обработчика.

**Прерывание** - сигнал от оборудования или программы для обработчика прервываний, чтобы уведомить процессор о необходимости особых действий.

Управление потоком команд осуществляется с помощью команд условного перехода. Они используют регистре machine status word, который содержит результат последней арифметической операции или команды `cmp`.

```assembly
cmp %rbx, %rax
jle label1 # переходим к метке label1, если RBX меньше или равен RAX
```

Системные вызовы помещают результат своего выполнения в регистр RAX. В случае ошибки там будет отрицательное значение. Для понимания ошибки абсолютное значение результата системного вызова можно сопоставить с константой из файла `errno.h`. Например, при попытке открытия несуществующего файла в RAX будет значение `-2`, что означает константу `ENOENT`. 

## Адреса

Адреса используются в качестве операндов при выполнений команд процессора. Адреса указывают на место в оперативной памяти. Но операндом может быть и регистр, в котором содержится нужный адрес.

- `$rdx` - адрес в регистре
- `(%rdx)` - значение по адресу из регистра (то же, что и разыменование указателя в Си)
- `16(%rdx)` - значение из регистра с увеличением адреса (смещение)
- `-8(%rdx)` - значение из регистра с уменьшением адреса
- `(%rdx, %rcx, 8)` - адрес массива, индекс и размер элемента (работа с массивами)
- `8(,%rax,4)` - RAX * 4 + 8
- `$var1` - адрес метки
- `(var1)` - значение по адресу в метке
- `(var1 + 1)` - со смещением


## Регистры

32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- RAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- RBX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- RCX — счетчик, его неявно используют некоторые команды для организации циклов.
- RDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- RSI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- RDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- RSP — указатель стека, указывает на вершину стека.
- RBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.
- RIP — указатель на текущую команду программы в памяти в виде смещения. Нельзя изменить напрямую.

Для частичного обращения в байтах к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

<https://ru.wikipedia.org/wiki/Регистровый_файл>

## Флаги

Отражают состояние процессора. Обычно хранятся в отдельных регистрах. Используются в командах условного перехода.

- CF - carry flag
- PF - parity flag
- ZF - zero flags - установлен, если результат ноль
- SF - sign flag
- OF - overflow flag - при перемещении не уместилось значение

## Стопка (stack)

Область памяти в конце адресного пространства процесса. Заполняется значениями, начиная со старшего адреса, командой `push`. Забираются значения с конца командой `pop` (при этом оно удаляется оттуда). Для взаимодействия с записанными значениями также используется смещение к записанному туда же значению адреса из регистра RBP, который используется для хранения RSP до перехода в подпрограммы. Регистр RSP всегда указывает на последнее значение в стопке. Его можно сдвигать вручную для увеличения стопки под разные задачи.

```
адреса ячеек памяти
                 ┌────────────────────────┐
  0x7fff3fedd7a8 │       значение 1       │
                 ├────────────────────────┤
  0x7fff3fedd7a0 │       значение 2       │
                 ├────────────────────────┤
  0x7fff3fedd798 │       значение 3       │
                 ├────────────────────────┤
  0x7fff3fedd790 │       значение 4       │
                 ├────────────────────────┤
  0x7fff3fedd780 │       значение 5       │
                 ├────────────────────────┤
  0x7fff3fedd778 │       значение 6       │ RSP, текущая вершина
                 ├────────────────────────┤
                 │                        │ очередной push поместит значение сюда
                 └────────────────────────┘
```

Чаще всего стопка используется при переходе в подпрограммы для передачи значений и хранения переменных во время выполнения подпрограммы. Вложенные переходы визуально образуют новые слои стопки.

Стопка может использоваться только для хранения значений с постоянным размером. Для хранения значений переменной длины используется куча.

## Куча (heap)

Способ использования выделенной процессу памяти путём смещения конца самой программы в памяти системным вызовом `brk` или`sbrk` (есть ещё `mmap`). Выделенное пространство начинается после областей text, data и bss.

```assembly
.globl _start

.data
var1:
.byte 123

.text
_start:
mov $0, %rdi          # записываем 0 в аргумент для brk
mov $12, %rax
syscall               # brk с нулевым смещением вернёт нам текущий конец программы

mov %rax, %r8         # сохраняем текущий конец программы, он будет началом кучи

lea 4096(%rax), %rdi  # новый адрес (4096 равен целой странице памяти)
mov $12, %rax         # выполняем brk для смещения конца программы
syscall

cmp $-1, %rax         # проверяем, если brk с ошибкой и вернул -1
jz exit               # выходим, если ошибка

mov (var1), %dl       # записываем значение, которое запишем в кучу
mov $0, %rbx          # записываем начальный индекс значений в куче

save:
mov %dl, (%r8, %rbx)  # записываем значение в кучу
inc %rbx              # увеличиваем индекс
cmp $4096, %rbx       # если индекс достиг конца,
jge free              # то перейти в free,
jmp save              # иначе повторить запись

free:
mov %r8, %rdi         # достаём старый конец программы
mov $12, %rax         # выполняем brk с ним для удаления кучи
syscall

exit:
mov $60, %rax
mov $0, %rdi
syscall
```

Запускаем программу с отображением системных вызовов brk

    strace -e brk ./prog1

_end

Для проверки правильности работы с кучей можно использовать Valgrind

    valgring ./prog1

## Подпрограмма

Отдельная последовательность команд с меткой в начале, к которой можно перейти и в конце вернутся обратно. При этом нужно сохранить в стопку регистры, чтобы они не были перезаписаны в подпрограмме. Иногда выделяется место в стопке для хранения временных значений при работе подпрограммы. В конце подпрограмм результат принято класть в RAX.

```assembly
.globl _start

somestring: .string "yoyoyo!\n"

mysubprogram:
# Сохранить текущий RBP в стопку для последующего восстановления
push %rbp

# Сохраняет текущую вершину стека в RBP, чтобы использовать его
# для обращения к другим значениям в стопке смещение адреса
mov %rsp, %rbp

# При необходимости выделяем в стопке пространство под переменные,
# сместив адрес RSP на их суммарный размер
sub $16, %rsp

# Если RBX, RDI или RSI будут использоваться в подпрограмме,
# то сохранить нужные в стопку для последующего восстановления
push %rbx
push %rdi
push %rsi

mov $1, %rax
mov $1, %rdi
mov 16(%rbp), %rsi
mov 24(%rbp), %rdx
syscall

# Поместить результат выполнения в RAX
mov $0, %rax

# Восстанавливаем значения RBX, RDI, RSI (в обратном порядке)
pop %rsi
pop %rdi
pop %rbx

# Если выделялось пространство под переменные, то
# освобождаем его уменьшением RSP или переносом RBP в RSP 
# (так как RBP был равнозначен RSP до выделения пространства под переменные)
mov %rbp, %rsp

# Восстановить старое значение RBP из стопки
pop %rbp

# Выполнить возврат из подпрограммы и удаление адреса возврата из стека
ret

_start:
# Если в RAX, RCX или RDX есть важные значения,
# то сохраняем нужные в стек для последующего восстановления
push %rax
push %rcx
push %rdx

# Сохраняем в стек любые значения, которые понадобятся внутри подпрограммы
push $8
push $somestring

# Переходим в подпрограмму, указав метку
# (при этом в стек запишется адрес возврата обратно)
call mysubprogram

# Очищаем стек от переданных значений, например,
# увеличив указатель RSP на общий размер переданных значений
add $16, %rsp

# Восстанавливаем из стека значения RAX, RCX, RDX
pop %rdx
pop %rcx
pop %rax

mov $60, %rax
mov $0, %rdi
syscall
```

Заполненная стопка при этом выглядит так

```
┌───────────────────────┐
│    сохранённый RAX    │
├───────────────────────┤
│    сохранённый RCX    │
├───────────────────────┤
│    сохранённый RDX    │
├───────────────────────┤
│ переданное значение 2 │ 24($rbp) обращение к значению через смещение
├───────────────────────┤
│ переданное значение 1 │ 16($rbp)
├───────────────────────┤
│    адрес возврата     │
├───────────────────────┤
│          RBP          │
├───────────────────────┤
│     переменная 1      │ -8($rbp)
├───────────────────────┤
│     переменная 2      │ -16($rbp)
├───────────────────────┤
│    сохранённый RBX    │
├───────────────────────┤
│    сохранённый RDI    │
├───────────────────────┤
│    сохранённый RSI    │
└───────────────────────┘
```

## Динамическая компоновка

При запуске программ может выполняться дополнительная компоновка с помощью отдельной программы - динамического компоновщика. Путь до него указывается в заголовке INTERP файла ELF.

Действия динамического компоновщика

1. запускается перед основной программой
2. проверяет динамические зависимости
3. запускает указанные в зависимостях библиотеки (могут иметь инициализацию)
4. заменяет метки основной программы на адреса из библиотек

Пример использования функции puts из стандартной библиотеки Си

```assembly
.globl _start

.data
mystr: .string "yoyoyo!"

.text
_start:
    leaq	mystr(%rip), %rax
    movq	%rax, %rdi
    call	puts

    mov $60, %rax
    mov $0, %rdi
    syscall
```

Сборка и компоновка

    as prog1.s -o prog1.o
    ld prog1.o --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -l c -o prog1

Опции

- `--dynamic-linker` - путь до динамического компоновщика
- `-l с` - добавление динамической зависимости с `/lib/x86_64-linux-gnu/libc.so`

Просмотреть используемые библиотеки

    readelf -dW prog1

Просмотреть зависимости

    readelf --dyn-syms prog1
    objdump -T prog1

Также можно запустить компоновщик с отслеживанием зависимостей

    ldd prog1

В зависимостях можно обнаружить vDSO (man vdso). Это небольшая библиотека, находящаяся в памяти Linux, для обработки частых системных вызовов. Она также используется для поддержки различных способов сделать системный вызов.

Динамический компоновщик `ld-linux-x86-64.so.2` является и исполняемым файлом и динамической библиотекой. Например, он содержит malloc. Но при запуске его malloc может быть заменён на тот, что в библиотеке libc.

С помощью переменной окружения LD_PRELOAD можно указать библиотеку, которая загрузится раньше других, таким образом подменив некоторый функционал из них. Например, `uncompress.so` добавит прозрачное разжатие при чтении данных.

Вынесем в библиотеку подпрограмму вывода текста и завершения

```assembly
.globl print, exit

print:
    push %rbp
    mov %rsp, %rbp

    mov $1, %rax
    mov $1, %rdi
    mov 16(%rbp), %rsi
    mov 24(%rbp), %rdx
    syscall

    mov $0, %rax
    pop %rbp
    ret

exit:
    mov $60, %rax
    mov $0, %rdi
    syscall
```

Сборка и компоновка

    as libtest1.s -o libtest1.o
    ld libtest1.o -shared -o libtest1.so

Имя динамических библиотек должно начинаться на `lib` и заканчиваться на `.so`.

Пример использования библиотеки

```assembly
.globl _start, print, exit

.data
str1: .string "yoyoyo!\n"
str2: .string "hello world?\n"

.text
_start:
    push $8
    push $str1
    call print
    add $16, %rsp

    push $14
    push $str2
    call print
    add $16, %rsp

    call exit
```

Сборка, компоновка и запуск

    as prog1.s -o prog1.o
    ld prog1.o -L . -l test1 --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o prog1
    LD_LIBRARY_PATH=. ./prog1

Опции

- `-l` - добавление динамической зависимости с `libtest1.so`
- `-L` - путь поиска библиотек

Во время запуска программы изменяем путь поиска библиотек с помощью переменной `LD_LIBRARY_PATH`, так как по умолчанию они не ищутся в текущей папке.

## gdb

Через отладчик можно выполнить программу пошагово и видеть значения регистров

    gdb prog1
    la asm
    la r
    b _start
    r
    si
    Enter
    Enter

Отобразить содержимое памяти по адресу

    x/8b &mystr

Отобразить стек

    i f
    x/100x $sp

Чтобы отладчик смог сопоставлять текущую команду с кодом программы неободимо добавить в файл отладочную информацию

    as -g prog1.s -o prog1.o && ld prog1.o -o .prog1

Отобразить код программы

    la src

## exec

При выполнении exec (подпрограмма из статической библиотеки libc) происходит

- разные проверки (права, необходимый объём памяти и т.д.)
- загрузка программы в оперативную память (вместо реальной загрузки происходит связывание файла с виртальной памятью и загрузка по мере необходимости)
- копирование в память переданных аргументов
- подготовка регистров (например, указателя на стек)
- перемещение в точку входа программы

Загрузка в память заменяет процесс, который был скопирован до этого командой fork. А также заново создаётся стек, куча (heap) и раздел изменяемых данных.





## Микрокод

Часть сложных команд процессора могут быть сделаны не на схеме, а в виде микропрограммы для устройства (микрокод), управляющего процессором. В основном это относится к процессорам архитектуры CISC, а в RISC - наоборот сохраняется минимальный набор простых команд, выполненных на схеме.

Команды на схеме работают быстрее и лучше для параллельных вычислений. Также программы часто используют простые операции.


