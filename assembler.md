# assembler

Ассемблер - язык команд самого процессора, а также программа-сборщик, которая читает файл с кодом и создаёт объектный файл с машинным кодом.

В отличии от большинства языков программирования для языка ассемблера нет стандарта, кроме документации от производителя для команд процессора и документации сборщика для команды сборщика.

Варианты

- nasm - Linux/FreeBSD, Intel syntax
- Borland Turbo Assembler (TASM)
- The GNU assembler (GAS), AT&T syntax
- Microsoft Assembler (MASM)
- fasm - Windows
- yasm - Windows

https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax

```asm
# Команды сборщика начинаются с точки, их выполняет сам сборщик, а не процессор.

.global _start      # делает метку доступной для линковки с другими объектными файлами

# Метки оканчиваются на двоеточие.
# Текстовые метки попадают в таблицу меток объектного файла.
# Точка в начале имени явно делает метку локальной.
# Числовые метки не попадают в таблицу меток.

_start:             # метка начала программы (если не указать, то сборщик назначит началом секцию text)

# Секции определяют расположение кода внутри объектного файла.
# Их можно не указывать вообще, тогда всё попадёт в секцию text,
# которая условно предназначена для кода программы.

.data               # поместить идущий далее код в секцию data

message:            # произвольная метка

.string "my text\n" # записать строки в итоговый объектный файл

.text               # поместить идущий далее код в секцию text

# Команды процессора обычно выглядят как "ДЕЙСТВИЕ ЧТО, КУДА",
# но может сокращаться, тогда используются значения по умолчанию для этой команды.

# Для начала заполним регистры процессора значениями

mov $4, %eax        # значение 4 в регистре eax означает sys_write
mov $1, %ebx        # файловый дескриптор 1 - это stdout процесса
mov $message, %ecx  # записать в регистор адрес строки
mov $8, %edx        # записать в регистр длину строки
int $0x80           # передаём поток выполнения программы в Linux

# Linux прочитает регистры и соответствующе отреагирует на их значения.

# Теперь необходимо правильно завершить программу.

mov $1, %eax        # sys_exit
mov $0, %ebx        # здесь будет код выхода программы
int $0x80
```

Сборка

    as myprogram.s -o myprogram.o

Компоновка

    ld myprogram.o -o myprogram

