# assembler

```assembly
mystr:
.string "yoyoyo!\n"

.globl _start

_start:
mov $1, %rax     # sys_write
mov $1, %rdi     # stdout
mov $mystr, %rsi # начало данных
mov $8, %rdx     # длина данных
syscall          # выполнить системный вызов

mov $60, %rax    # sys_exit
mov $0, %rdi     # значение выхода программы
syscall
```

Сборка в исполняемую программу и запуск

    as prog1.s -o prog1.o
    ld prog1.o -o prog1
    ./prog1

Описание

1. Сборщик выполняет команды сборщика, переводит команды процессора в машинный формат, состоящий из кодов операций, и сохраняет результат в файл ELF перемещаемого типа
2. Компоновщик ld (Link eDitor) заменяет текстовые метки на адреса и объединяет несколько ELF в один, получая в итоге
    - исполняемый ELF
    - совместно используемый ELF (динамические библиотеки)
    - перемещаемый ELF (статические библиотеки)
 3. Запуск программы через системные вызовы fork и exec
    - fork полностью копирует родительский процесс памяти
    - exec вызывает загрузчик программ

Также любую программу можно обратно перевести в ассемблер

    objdump -d prog1 | less

Для языка ассемблера нет стандарта, кроме документации от производителя процессора. Наиболее распространённой архитектурой процессора является Intel x86-64.

Разновидности

- gas - The GNU assembler, Linux, синтаксис [AT&T](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
- nasm - синтаксис Intel
- yasm - переделка nasm
- fasm - свободный, использован для написания MenuetOS/KolibriOS, может обойтись без компоновщика
- tasm - Borland, не поддерживается
- masm - Microsoft, MS-DOS, Windows

Код программы состоит из команд ассемблера и команд процессора. Команды ассемблера `.byte`, `.string` и подобные сохраняют произвольное значение в будущую программу. Команды процессора превращаются в машинный формат (точнее опкод - код операции) один к одному. Внутри команд можно обращаться по адресу к сохранённым данным или командам процессора (например, для перехода), потому что при запуске программы всё это загружается в память и становится адресуемым пространством. Но будущий адрес программы в памяти заранее неизвестен, поэтому используются **метки**.

## Метки

Расставляются в коде программы, попадают в таблицу меток ELF и заменяются при компоновке на адреса сразу при компоновке (статическая компоновка), либо при запуске программы (динамическая компоновка).

```assembly
myvar:              # метка
.byte 30            # сохранить число (адрес будет $myvar)
.byte 55            # адрес со смещением $myvar+1

othervar: .short 50 # можно писать команды сразу после метки

myarray:
.byte 51, 52, 53    # массив $myarray, $myarray+1, $myarray+2

.globl _start       # определяем глобальные метки

_start:             # точка входа в программу по умолчанию
    mov $60, %rax
    mov $0, %rdi
    syscall
```

При компоновке нескольких ELF в один между ними видны только глобальные метки. Точка в начале имени делает метку локальной явно. Числовые метки всегда локальные.

## Разделы

Код программы размещается в файле ELF в раздел text, data и другие. В зависимости от раздела этот участок программы будет загружен в соответствующий тип памяти в железе. Для помещения участка программы в нужный раздел расставляются команды сборщика.

```assembly
.data                   # поместить код далее в раздел data

var1: .byte 10

var2: .string "text1\n"

.text                   # поместить код далее в раздел text

_start:
    mov $60, %rax
    mov $0, %rdi
    syscall

.data                   # снова раздел data

var3: .byte 1, 2, 3
```

Раздел text используется для постоянных данных (для команд процессора и констант, попытка изменения в процессе работы программы приведёт к падению), data - для данных, которые программа может изменить в процессе работы (размещение здесь команд может вызвать ошибку безопасности). Без указания раздела всё попадает в text.

Посмотреть разделы в ELF файле можно так

    readelf -lW prog1

## Команды сборщика

- `.text` - помещение кода в раздел text
- `.data` - помещение кода в раздел data
- `.byte` - сохранить значения в файле программы
- `.string` - сохранить строки с нулевым байтом (обозначает конец строки) в файле программы
- `.globl` - сделать метки глобальными

## Команды процессора

- перемещение буквальных значений, адресов или значений регистров
    - mov - в другой регистр
    - push - в стек (также уменьшает указатель стека)
    - pop - из стека в регистр
    - lea - взять адрес и переместить (получаем указатель)
- арифметика: add, sub, inc, dec, imul, idiv, and, or, xor, not, neg, shl, shr
- управление потоком команд: jmp, je, jne, jz, jg, jge, jl, jle, cmp, call, ret
- enter - создать кадр стека
- leave - обратить действие enter
- syscall - выполнение системного вызова

В x86 для системных вызовов использовалось программное прерывание `int 0x80`, но из-за разности привелегий процесса и обработчика процессор делал много лишний действий для переноса данных в стек обработчика. Позже появилась команда `syscall`, которая быстро переходит на уровень привелегий обработчика.


**Прерывание** - сигнал от оборудования или программы для обработчика прервываний, чтобы уведомить процессор о необходимости каких-то действий.

При выполнений команд длина учитывается в байтах. По умолчанию длина определяется по регистру. Ножелательно явно указать длину через имя команды

- `movb` - byte, 1 байт, 8 бит
- `movw` - word, 2 байта, 16 бит
- `movl` - long, 4 байта, 32 бита
- `movq` - quad, 8 байт, 64 бита

## Адреса

Адреса используются для указания расположения в памяти.

- `(%rbx)` - прочитать адрес в регистре и обратиться по адресу в память
- `16(%rbx)` - тоже самое, но с увеличением адреса на 16 байт (смещение, offset)

## Регистры

32/64-битные ячейки памяти внутри процессора для временного хранения значений при выполнении команд. Назначение регистров условное, но есть общепринятые соглашения.

- RAX — аккумулятор, применяется для хранения результатов промежуточных вычислений.
- RBX — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
- RCX — счетчик, его неявно используют некоторые команды для организации циклов.
- RDX — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
- RSI — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
- RDI — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
- RSP — указатель стека, указывает на вершину стека.
- RBP — указатель базы кадра стека. Предназначен для организации произвольного доступа к данным внутри стека.

Для частичного обращения в байтах к регистру изменяется его имя по следующей схеме

```
|  64  |  56  |  48  |  40  |  32  |  24  |  16  |   8  |
|                          RAX                          |
|                           |            EAX            |
|                                         |      AX     |
|                                         |  AH  |  AL  |
```

## Стек

Способ временного выделения памяти для программы с помощью команд `push` и `pop`. При выполнении `push` в стек сохраняется значение, при этом увеличивается регистр RSP на длину значения. Регистр RSP всегда содержит адрес текщего последнего значения в стеке (вершина стека).

```
     ┌───────────────────────┐
     │      значение 1       │
     ├───────────────────────┤
 ▲   │      значение 2       │   │
 │ а ├───────────────────────┤   │
 │ д │      значение 3       │ p │
 │ р ├───────────────────────┤ u │
 │ е │      значение 4       │ s │
 │ с ├───────────────────────┤ h │
 │ а │      значение 5       │   │
 │   ├───────────────────────┤   ▼   вершина стека
     │      значение 6       │◄────────────────
     └───────────────────────┘
```

## Куча

Выделение памяти в программе путём смещения конца области данных. Обычно это делают высокоуровневые языки, отвечая также за управление пространством в куче.

Для корректности работы с кучей можно использовать Valgrind

    valgring ./prog1

## Подпрограмма

Самостоятельный участок программы в виде нескольких команд с меткой в начале, к которому переходят несколько раз и возвращаются обратно, возможно, также получая некий результат работы.

При работы подпрограммы используется стек.

При обращений к подпрограммам и их выполнении соблюдается ряд правил для корректной работы программы. 

```assembly
.globl _start

somestring: .string "yoyoyo!\n"

mysubprogram:
        # Сохранить текущий RBP в стек для последующего восстановления
        push %rbp

        # Сохраняет текущую вершину стека в RBP, чтобы использовать его
        # для поиска других значений в стеке смещением
        mov %rsp, %rbp

        # При необходимости выделить в стеке пространство под переменные,
        # например, сместив адрес RSP на их суммарный размер
        sub $16, %rsp

        # Если RBX, RDI или RSI будут использоваться в подпрограмме,
        # то сохранить нужные в стек для последующего восстановления
        push %rbx
        push %rdi
        push %rsi

        mov $1, %rax
        mov $1, %rdi
        mov 16(%rbp), %rsi
        mov 24(%rbp), %rdx
        syscall

        # Поместить результат выполнения в RAX
        mov $0, %rax

        # Восстановить RBX, RDI, RSI из стека в обратном порядке
        pop %rsi
        pop %rdi
        pop %rbx

        # Если выделялось пространство под переменные,
        # то освободить его уменьшением RSP или переносом RBP в RSP 
        # (так как RBP был равнозначен RSP до выделения пространства под переменные)
        mov %rbp, %rsp

        # Восстановить старое значение RBP из стека
        pop %rbp

        # Выполнить возврат из подпрограммы и удаление адреса возврата из стека
        ret

_start:
        # Если в RAX, RCX или RDX есть важные значения,
        # то сохраняем нужные в стек для последующего восстановления
        push %rax
        push %rcx
        push %rdx

        # Сохранить в стек любые значения, которые понадобятся внутри подпрограммы
        push $8
        push $somestring

        # Выполнить переход в подпрограмму, указав метку
        # (также сохранится адрес возврата в стек)
        call mysubprogram

        # Очистить стек от переданных в подпрограмму значений,
        # например, увеличив указатель стека на сумму размера значений
        add $16, %rsp

        # Восстановить в обратном порядке сохранённые ранее в стек
        # значения RAX, RCX, RDX
        pop %rdx
        pop %rcx
        pop %rax

        mov $60, %rax
        mov $0, %rdi
        syscall
```

Стек

```
     ┌───────────────────────┐
     │    сохранённый RAX    │
     ├───────────────────────┤
     │    сохранённый RCX    │
     ├───────────────────────┤
     │    сохранённый RDX    │
     ├───────────────────────┤
     │ переданное значение 2 │ 24($rbp)
     ├───────────────────────┤
     │ переданное значение 1 │ 16($rbp)
     ├───────────────────────┤
     │    адрес возврата     │
     ├───────────────────────┤
     │    сохранённый RBP    │
     ├───────────────────────┤
     │     переменная 1      │ -8($rbp)
     ├───────────────────────┤
     │     переменная 2      │ -16($rbp)
     ├───────────────────────┤
     │    сохранённый RBX    │
     ├───────────────────────┤
     │    сохранённый RDI    │
     ├───────────────────────┤
     │    сохранённый RSI    │
     └───────────────────────┘
```

## Динамическая компоновка

Компоновка при запуске программы выполняется отдельной программой - динамическим компоновщиком.

В файле ELF в заголовке INTERP может быть указана программа выполняющая роль динамического компоновщика. Если она указана, тогда она

1. запускается перед нашей программой
2. проверяет динамические зависимости
3. запускает указанные в зависимостях библиотеки
4. заменяет метки на адреса

Пример использования функции puts из стандартной библиотеки Си

```assembly
.globl _start

.data

mystr:
.string "yoyoyo!"

.text

_start:

leaq	mystr(%rip), %rax
movq	%rax, %rdi
call	puts

mov $60, %rax
mov $0, %rdi
syscall
```

Сборка и компоновка

    as prog1.s -o prog1.o
    ld prog1.o --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -l c -o prog1

Опции

- `--dynamic-linker` - путь до динамического компоновщика
- `-l с` - добавление динамической зависимости с `/lib/x86_64-linux-gnu/libc.so`

Зависимости указаны в файле

    readelf -dW prog1

Либо можно запустить компоновщик с отслеживанием зависимостей

    ldd prog1

В зависимости также попадает vDSO - небольшая библиотека, находящаяся в памяти Linux, для обработки частых системных вызовов. Она также используется и для поддержки различных способов сделать системный вызов (man vdso).

Динамический компоновщик `ld-linux-x86-64.so.2` является и исполняемым файлом и динамической библиотекой. Например, он содержит malloc. Но при запуске его malloc может быть заменён на тот, что в библиотеке libc.

С помощью переменной окружения LD_PRELOAD можно указать библиотеку, которая загрузится раньше других, таким образом подменив некоторый функционал из них. Например, `uncompress.so` добавит прозрачное разжатие при чтении данных.

### Пример библиотеки

Вынесем в библиотеку подпрограмму вывода текста и завершения

```assembly
.globl print, exit

print:
push %rbp
mov %rsp, %rbp

mov $1, %rax
mov $1, %rdi
mov 16(%rbp), %rsi
mov 24(%rbp), %rdx
syscall

mov $0, %rax
pop %rbp
ret

exit:
mov $60, %rax
mov $0, %rdi
syscall
```

Сборка и компоновка

    as libtest1.s -o libtest1.o
    ld libtest1.o -shared -o libtest1.so

Имя динамических библиотек должно начинаться на `lib` и заканчиваться на `.so`.

Пример использования библиотеки

```assembly
.globl _start, print, exit

.data
str1:
.string "yoyoyo!\n"
str2:
.string "hello world?\n"

.text
_start:
push $8
push $str1
call print
add $16, %rsp

push $14
push $str2
call print
add $16, %rsp

call exit

```

Сборка, компоновка и запуск

    as prog1.s -o prog1.o
    ld prog1.o -L . -l test1 --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o prog1
    LD_LIBRARY_PATH=. ./prog1

Опции

- `-l` - добавление динамической зависимости с `libtest1.so`
- `-L` - путь поиска библиотек

Во время запуска программы изменяем путь поиска библиотек с помощью переменной `LD_LIBRARY_PATH`, так как по умолчанию они не ищутся в текущей папке.

## Загрузчик программ

При выполнении execve (подпрограмма из статической библиотеки libc) происходит

- разные проверки (права, необходимый объём памяти и т.д.)
- загрузка программы в оперативную память (вместо реальной загрузки происходит связывание файла с виртальной памятью и загрузка по мере необходимости)
- копирование в память переданных аргументов
- подготовка регистров (например, указателя на стек)
- перемещение в точку входа программы

Загрузка в память заменяет процесс, который был скопирован до этого командой fork. А также заново создаётся стек, куча (heap) и раздел изменяемых данных.




## Микрокод

Часть сложных команд процессора могут быть сделаны не на схеме, а в виде микропрограммы для устройства (микрокод), управляющего процессором. В основном это относится к процессорам архитектуры CISC, а в RISC - наоборот сохраняется минимальный набор простых команд, выполненных на схеме.

Команды на схеме работают быстрее и лучше для параллельных вычислений. Также программы часто используют простые операции.

